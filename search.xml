<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构第四章</title>
      <link href="/2022/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2022/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第四章"><a href="#数据结构第四章" class="headerlink" title="数据结构第四章"></a>数据结构第四章</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将博客部署到github</title>
      <link href="/2022/03/02/%E5%8D%9A%E5%AE%A2/%E5%B0%86%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/"/>
      <url>/2022/03/02/%E5%8D%9A%E5%AE%A2/%E5%B0%86%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h1><h2 id="什么是GitHub"><a href="#什么是GitHub" class="headerlink" title="什么是GitHub"></a>什么是GitHub</h2><p>GitHub是一个面向开源及私有软件项目的托管平台，功能杠杠的，这里我们就用到它的其中一个功能，免费部署静态网站。<a href="https://github.com/">GitHub</a></p><h2 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h2><ol><li>在GitHub官网<a href="https://link.zhihu.com/?target=https://github.com/">https://github.com/</a>注册账户并登陆。</li><li>创建一个新仓库(repository)，名称<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>，username是github用户名。然后依次进行下面四步操作：<ul><li>点击右上角的账户图标 </li><li>点击”Your profile” </li><li>点击”Repositories” </li><li>点击new</li></ul></li></ol><p><img src="https://pic3.zhimg.com/v2-f9644333b89cf932682cf495ddedd32e_r.jpg" alt="图片"></p><ol start="3"><li>仓库名称填写 github用户名.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a>，如图所示，这里演示的用户名是robotdigital，所以填<a href="https://link.zhihu.com/?target=http://robotdigital.github.io">http://robotdigital.github.io</a>，勾选“带README的仓库”，最后点击“Creat repository”</li></ol><p>  <img src="https://pic4.zhimg.com/v2-84b436c2285c66c452877fa80a2b54bb_r.jpg" alt="图片2"></p><ol start="4"><li>则成功创建了一个名为<a href="https://link.zhihu.com/?target=http://robotdigital.github.io">http://robotdigital.github.io</a>的repository（仓库）</li></ol><p><img src="https://pic3.zhimg.com/v2-b8dafc2093fcf7d48e9af14a667cbfba_r.jpg" alt="图片3"></p><h2 id="博客部署-1"><a href="#博客部署-1" class="headerlink" title="博客部署"></a>博客部署</h2><ol><li>打开hexo博客所在的blog文件夹中的_config.yml，在Deployment模块配置如图所示的信息（注意repository要换成自己GitHub仓库中的哦）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:peter-ggb/peter-ggb.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>repository内容如图所示：</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220303135640419.png" alt="图片"></p><p>注意：编辑config.yml 文件时 有严格的语法要求，包括空格，不能随意更改</p><ol start="2"><li>在blog文件下打开git Bash输入以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这行命令的含义是将本地文件部署到你的GitHub库中，与下面的命令作用是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>结果发现如图所示的报错，Permission denied(publickey)，拒绝访问（公共密钥）</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220303141817461.png" alt="image-20220303141817461"></p><h2 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h2><p>因为没有将本机加入到GitHub的信任名单中，所以将博客发布到GitHub服务器这样的远程操作被拒绝。 接下来我们需要创建SSH key（简单说，SSH是一种网络协议，用于计算机之间的加密登录） 。</p><ol><li><p>首先进入gitHub，点击右上角的头像，选择settings，在左边选择SSH and GPG keys ，点击New SSH key，然后会让你选择时间以及其他选项（在这里我做的选择是90天，然后下面的全部勾选，根据自己的需求做合理的调整）</p></li><li><p>然后这里需要我们输入密钥，标题随意命名，这里我们先等下再填</p></li><li><p>然后进入blog文件下打开git bash，输入如下命令,邮箱名就是你注册GitHub上所用的邮箱名</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱名&quot;</span><br></pre></td></tr></table></figure><p>回车执行命令，然后就是这样</p><p><img src="https://pic4.zhimg.com/v2-aae30fb6e47e7eb0074522f9ed6b4e33_r.jpg" alt="图片5"></p><p>现在是要求我们输入密码，这个密码会在我们提交项目时使用，如果为空的话提交项目时则不用输入。防止别人往你的项目里提交内容，这里我选择输入了自己的密码，密码就是你注册GitHub上的密码，这样就成功生成了密钥，并且密钥信息存储在<strong>C:\Users\CNBOXIA1.ssh\id_rsa.pub</strong> 中。</p><p><img src="https://pic3.zhimg.com/v2-3b42b3fad78ee146cdd1111171af18d2_r.jpg" alt="图片6"> </p><p>用记事本打开id_rsa.pub文件，将里面的内容复制到Key输入框中，最后点击“Add SSH key”。</p><p><img src="https://pic2.zhimg.com/v2-66ae7414d4e1f5f196ced32080378621_r.jpg" alt="图片4"></p><p>这样密钥就添加成功了</p><p>注意：这里一定要将密钥保存下来，比如存在你的记事本里，手机拍照等等，因为等你添加密钥之后他就会隐藏不再显示，再想获取这个密钥就不太可能了，千万要保存！千万要保存！千万要保存！</p><p>当然如果没保存也有解决办法，就是再创建一个密钥，这两个密钥对下面的操作影响是一样的，也可以同时存在，只是要再花时间去创建而已（我就是重新创建了一个)</p><h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>在blog文件夹下执行以下命令,hexo clean代表清理缓存,hexo g代表部署之前预先生成静态文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220303143829094.png" alt="image-20220303143829094"></p><p>无报错，表示部署成功。</p><p>过一小会，在浏览器中输入<a href="https://link.zhihu.com/?target=http://robotdigital.github.io">http://robotdigital.github.io</a>（robotdigital替换成自己创建的github用户名），则成功看到了博客页面，表明我们成功将个人博客发布到了GitHub上。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220303143955230.png" alt="image-20220303143955230"></p><p>快去看看吧</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第一章</title>
      <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第一章"><a href="#数据结构第一章" class="headerlink" title="数据结构第一章"></a>数据结构第一章</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h3><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</p><h3 id="数据结构的组成"><a href="#数据结构的组成" class="headerlink" title="数据结构的组成"></a>数据结构的组成</h3><p>包括逻辑结构和存储结构两个层次</p><p>逻辑结构：</p><p>先说逻辑结构，逻辑结构是从逻辑关系上描述数据</p><p>逻辑结构有两个要素：数据元素和关系，通常有四类基本特征，复杂程度依次递进<br>如下图所示：<br><img src="D:\blog\source\img/tu1.png" alt="图1"></p><ul><li>集合结构：除了属于同一集合的关系外，没有别的关系</li><li>线性结构：数据元素存在一对一的关系</li><li>树结构：数据元素之间存在一对多的关系</li><li>图结构或网状结构：数据元素之间存在多对多的关系</li></ul><p>还可以从线性和非线性的角度给逻辑结构分类<br>如下图所示：<br><img src="D:\blog\source\img/tu2.png" alt="图2"></p><p>存储结构：</p><p>数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构</p><p>数据的存储结构会影响</p><ul><li>1.存储空间分配的方便程度</li><li>2.对数据运算的速度</li></ul><p>数据元素在计算机中有四种存储结构，分别是：</p><ul><li>顺序存储  顺序存储 借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系</li><li>链式存储  非顺序存储 无需占用一整块存储空间，也就是说不要求物理上相邻</li><li>索引存储  非顺序存储 建立附加的索引表，索引表中每项是索引项</li><li>散列存储  非顺序存储 （还需补充）</li></ul><h3 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h3><p>数据的运算包括：检索，排序，修改，插入，删除等</p><h3 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h3><p>数据类型：</p><ul><li>原子类型：不可再分的类型（如int）</li><li>结构类型：可再分的类型（如struct）</li></ul><p>抽象数据类型：<br>一般是指由用户定义的，表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：</p><ul><li>数据对象</li><li>数据对象上关系的集合</li><li>对数据对象的基本操作的集合、</li></ul><p>抽象数据定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">    数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">    数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">    基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><p>数据对象和数据关系的定义采用数学符号和自然语言描述，基本格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本操作名（参数表）</span><br><span class="line">     基本条件：&lt;初始条件描述&gt;</span><br><span class="line">     操作结果：&lt;操作结果描述&gt;</span><br></pre></td></tr></table></figure><h3 id="算法定义及特征"><a href="#算法定义及特征" class="headerlink" title="算法定义及特征"></a>算法定义及特征</h3><p>一个算法必须满足以下五个重要特性</p><ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ul><h3 id="评价算法优劣的基本准则"><a href="#评价算法优劣的基本准则" class="headerlink" title="评价算法优劣的基本准则"></a>评价算法优劣的基本准则</h3><ul><li>正确性</li><li>可行性</li><li>健壮性</li><li>高效性</li></ul><h3 id="算法的时间复杂度计算"><a href="#算法的时间复杂度计算" class="headerlink" title="算法的时间复杂度计算"></a>算法的时间复杂度计算</h3><p>加法规则：多项相加，只保留最高阶的项且系数为1<br>乘法规则：多项相乘，都保留</p><p>算法的时间复杂度O(1)&lt;O($$log_2n $$)&lt;O(n)&lt;O($$nlog_2 n$$)&lt;O($$ n^2$$)&lt;O($$ n^3$$)&lt;O($$ 2^n$$)&lt;O(n!)&lt;O($$n^n$$);</p><p>复杂度口诀：常对幂指阶（常数&lt;对数&lt;幂&lt;指数&lt;阶数）</p><p>最好、最坏和平均时间复杂度（有待更新）</p><p>注意：</p><ul><li>顺序执行的代码只会影响常数项，可以忽略</li><li>只需挑循环中一个基本操作分析它的执行次数与n的关系即可</li><li>如果有多层嵌套循环只需关注，最深层循环了几次</li></ul><h3 id="算法的空间复杂度计算"><a href="#算法的空间复杂度计算" class="headerlink" title="算法的空间复杂度计算"></a>算法的空间复杂度计算</h3><p>复杂度口诀：常对幂指阶（常数&lt;对数&lt;幂&lt;指数&lt;阶数）</p><p>空间复杂度&#x3D;递归调用的深度<br>（有待继续总结）</p><p>注意</p><ul><li>算法原地工作&#x3D;算法所需的内存空间为常量</li></ul><p>最后总结：<br><img src="D:\blog\source\img/tu3.png" alt="图3"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第三章</title>
      <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第三章"><a href="#数据结构第三章" class="headerlink" title="数据结构第三章"></a>数据结构第三章</h1><h2 id="栈的定义和特点"><a href="#栈的定义和特点" class="headerlink" title="栈的定义和特点"></a>栈的定义和特点</h2><p>栈是限定仅在表尾进行插入或删除操作的线性表，表尾端有特殊含义，称为栈顶，表头段称为栈底，不含元素的空表称为空栈，又称为后进后出的线性表</p><p>逻辑结构：与普通列表相同</p><h2 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a>队列的定义和特点</h2><p>队列与栈相反，是先进先出的线性表，只允许在表的一端进行插入，另一端允许删除，允许插入的一端称为队尾，允许删除的一端称为队头</p><h2 id="栈的表示和实现"><a href="#栈的表示和实现" class="headerlink" title="栈的表示和实现"></a>栈的表示和实现</h2><h3 id="栈类型的定义"><a href="#栈类型的定义" class="headerlink" title="栈类型的定义"></a>栈类型的定义</h3><p>基本操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">InitStack</span>(&amp;S) <span class="comment">//构造一个空栈</span></span><br><span class="line"><span class="built_in">DestroyStack</span>(&amp;S) <span class="comment">//销毁栈S</span></span><br><span class="line"><span class="built_in">ClearStack</span>(&amp;S) <span class="comment">//将S清为空栈</span></span><br><span class="line"><span class="built_in">StackEmpty</span>(S) <span class="comment">//若栈为空栈，返回true，若非空则返回False</span></span><br><span class="line"><span class="built_in">StackLength</span>(S) <span class="comment">//返回S的元素个数</span></span><br><span class="line"><span class="built_in">GetTop</span>(S) <span class="comment">//返回栈顶指针元素，不修改栈顶指针</span></span><br><span class="line"><span class="built_in">Push</span>(&amp;S,e) <span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line"><span class="built_in">Pop</span>(&amp;S,e) <span class="comment">//删除S的栈的元素</span></span><br><span class="line"><span class="built_in">StackTraverse</span>(S) <span class="comment">//从栈底到栈顶依次对S的每个数据元素进行访问</span></span><br></pre></td></tr></table></figure><h3 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h3><p>顺序栈存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemTyoe *base;<span class="comment">//栈底指针</span></span><br><span class="line">    SElemType *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="type">int</span> stacksize；<span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>顺序栈的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序栈的入栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base==MAXSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line">    *S.top++=e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序栈的出栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=*--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取栈顶元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> *(S.top<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h3><p>链栈的存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StackNode</span> *next;</span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure><p>链栈的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的入栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    StackNode p=<span class="keyword">new</span> StackNode;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S;</span><br><span class="line">    S=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的出栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=S-&gt;data;</span><br><span class="line">    p=S;</span><br><span class="line">    S=S-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取链栈元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><p>遍历输出链表中各个结点的递归算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseList</span><span class="params">(LinkList p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p=<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;p&lt;&lt;p-&gt;data;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="built_in">TraverseList</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hanoi塔问题的递归问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> A,<span class="type">char</span> B,<span class="type">char</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="built_in">move</span>(A,<span class="number">1</span>,C);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">Hanoi</span>(n<span class="number">-1</span>,A,C,B);</span><br><span class="line">        <span class="built_in">move</span>(A,n,C);</span><br><span class="line">        <span class="built_in">Hanoi</span>(n<span class="number">-1</span>,B,A,C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据最终结果计算，递归算法计算Fibonacci和Hanoi问题算法时间复杂度都是o($$2^n $$)</p><h2 id="队列的表示和实现"><a href="#队列的表示和实现" class="headerlink" title="队列的表示和实现"></a>队列的表示和实现</h2><h3 id="队列的类型定义"><a href="#队列的类型定义" class="headerlink" title="队列的类型定义"></a>队列的类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ADT Quene&#123;</span><br><span class="line">     <span class="built_in">InitQuene</span>(&amp;Q) <span class="comment">//构造一个空队列</span></span><br><span class="line">     <span class="built_in">DestroyQuene</span>(&amp;Q) <span class="comment">//x销毁队列Q</span></span><br><span class="line">     <span class="built_in">ClearQuene</span>(&amp;Q) <span class="comment">//将Q置为空队列</span></span><br><span class="line">     <span class="built_in">QueneEmpty</span>(Q) <span class="comment">//若Q为空返回true，反之则为false</span></span><br><span class="line">     <span class="built_in">QueneLength</span>(Q) <span class="comment">//返回Q的元素个数即队列长度    </span></span><br><span class="line">     <span class="built_in">GetHead</span>(Q) <span class="comment">//返回Q的队头元素  </span></span><br><span class="line">     <span class="built_in">EnQuene</span>(&amp;Q,e) <span class="comment">//插入元素e为队尾元素</span></span><br><span class="line">     <span class="built_in">DeQuene</span>(&amp;Q,&amp;e) <span class="comment">//删除Q的队头元素，并用e返回其值</span></span><br><span class="line">     <span class="built_in">QueneTraverse</span>(Q) <span class="comment">//从队头到队尾依次对每个数据元素进行访问    </span></span><br><span class="line">&#125;ADT Quene</span><br></pre></td></tr></table></figure><h3 id="循环队列的顺序表示和实现"><a href="#循环队列的顺序表示和实现" class="headerlink" title="循环队列的顺序表示和实现"></a>循环队列的顺序表示和实现</h3><p>循环队列的顺序存储形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QElemType *base;<span class="comment">//存储空间的基地址</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">//头指针</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQuene;</span><br></pre></td></tr></table></figure><p>循环队列的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQuene</span><span class="params">(SqQuene &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.base=<span class="keyword">new</span> QElemTyoe[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!Q) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求循环队列的长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueneLength</span><span class="params">(SqQuene Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQuene</span><span class="params">(SqQuene &amp;Q,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXSIZE==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.<span class="built_in">base</span>(Q.rear)=e;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列出队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQuene</span><span class="params">(SqQuene &amp;Q,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=Q.<span class="built_in">base</span>(Q.front);</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取循环队列的对头元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QElemType <span class="title">GetTop</span><span class="params">(SqQuene Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> Q.<span class="built_in">base</span>(Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式表示和实现"><a href="#队列的链式表示和实现" class="headerlink" title="队列的链式表示和实现"></a>队列的链式表示和实现</h3><p>队列的链式存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span>  <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QuenePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QuenePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QuenePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQuene;</span><br></pre></td></tr></table></figure><p>链队列的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQuene</span><span class="params">(LinkQuene &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=<span class="keyword">new</span> QNode;</span><br><span class="line">    Q.front=Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链队列的入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQuene</span><span class="params">(LinkQuene &amp;Q,QElemType e)</span></span>&#123;</span><br><span class="line">    QNode p=<span class="keyword">new</span> Node;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链队列的出队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQuene</span><span class="params">(LinkQuene &amp;Q,QElemtype e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p) Q,rear=Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取链队列的队头元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetHead</span><span class="params">(LinkQuene Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front!=Q.rear)</span><br><span class="line">        <span class="keyword">return</span> Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p>数制的转换</p><p>将一个十进制整数N转换为八进制数时，在计算过程中，把N与8求余得到的八进制数依次出栈输出，输出结果就是带求得得八进制数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(N/<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="type">int</span> e=N%<span class="number">8</span>;</span><br><span class="line">        <span class="built_in">Push</span>(&amp;S,e);</span><br><span class="line">        N/=<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(&amp;S,e);</span><br><span class="line">        cout&lt;&lt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>括号匹配的检验</p><p>检验算法借助一个栈，每当读入一个左括号，则直接入栈，等待相匹配的同类右括号，当读入一个右括号，若与当前栈顶的左括号类型相同则二者匹配，即将栈顶的左括号出栈，直接表达式扫描完毕。</p><p>在扫描过程中，还要考虑符号不匹配出错的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Matching</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;#&#x27;</span>&amp;&amp;flag)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                <span class="built_in">Push</span>(&amp;S,e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(!StackEmpty&amp;&amp;GetTop==<span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                    <span class="built_in">Pop</span>(&amp;S,e);</span><br><span class="line">                <span class="keyword">else</span> flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(!StackEmpty&amp;&amp;GetTop==<span class="string">&#x27;[&#x27;</span>) </span><br><span class="line">                    <span class="built_in">Pop</span>(&amp;S,e);</span><br><span class="line">                <span class="keyword">else</span> flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty&amp;&amp;flag!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式求值</p><p>遵循三条规则</p><ol><li>先乘除，后加减</li><li>从左算到右</li><li>先括号内，后括号外</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">EvaluateExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPND);</span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR);</span><br><span class="line">    <span class="built_in">push</span>(&amp;OPTR,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;#&#x27;</span>||<span class="built_in">GetTop</span>(OPTR)!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                <span class="built_in">push</span>(OPND,ch);</span><br><span class="line">                cin&gt;&gt;ch;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                <span class="built_in">Pop</span>(OPTR,fuhao);</span><br><span class="line">                <span class="built_in">Pop</span>(OPND,e1);</span><br><span class="line">                <span class="built_in">Pop</span>(OPND,e2);</span><br><span class="line">                <span class="built_in">Push</span>(OPND,<span class="built_in">Operate</span>(e1,fuhao,e2));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                <span class="built_in">Pop</span>(OPTR,e3);</span><br><span class="line">                cin&gt;&gt;ch;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetTop</span>(OPND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>舞伴问题</p><p>会场中有若干男舞者和若干女舞者，需要将他们一 一配对</p><p>解决这个问题我们首先要写出舞者的数据结构</p><p>这里我们用链队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    String name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;Person;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    Person *base; <span class="comment">//指向peron的指针</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;SQuene;</span><br><span class="line">SQuene manQuene,womanQuene;<span class="comment">//分别存放男舞者队列与女舞者队列</span></span><br></pre></td></tr></table></figure><p>之后来解决问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DanceProblem</span><span class="params">(Person Dancer[],<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitQuene</span>(manQuene);</span><br><span class="line">    <span class="built_in">InitQuene</span>(womanQuene);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dancer[i].sex==<span class="string">&#x27;m&#x27;</span>) <span class="built_in">EnQuene</span>(manQuene,Dancer[i]);</span><br><span class="line">        <span class="keyword">if</span>(Dancer[i].sex==<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">EnQuene</span>(womanQuene,Dancer[i]);       </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">QueneEmpty</span>(manQuene)&amp;&amp;!<span class="built_in">QueneEmpty</span>(womanQuene))&#123;</span><br><span class="line">        <span class="built_in">DeQuene</span>(manQuene,p);</span><br><span class="line">        cout&lt;&lt;p.name&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">DeQuene</span>(womanQuene,w);</span><br><span class="line">        cout&lt;&lt;w.name&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">QueneEmpty</span>(manQuene))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;现在等待舞伴的第一个男舞者：&quot;</span>&lt;&lt;p.name&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">QueneEmpty</span>(womanQuene))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;现在等待舞伴的第一个女舞者：&quot;</span>&lt;&lt;w.name&lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220308155251329.png" alt="图片"></p><p>第三章完结</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第二章</title>
      <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第二章"><a href="#数据结构第二章" class="headerlink" title="数据结构第二章"></a>数据结构第二章</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>特点：同一线性表中的元素必定具有相同的特性，即同属于同一数据对象，相邻数据元素之间存在着序偶关系。</p><p>定义：由n（n&gt;&#x3D;0）个数据特性相同的元素对象组成的有限序列，称为线性表，n为线性表的长度，n&#x3D;0时为空表</p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h2><p>基本操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">InitList(&amp;L) <span class="comment">//建立一个空的线性表</span></span><br><span class="line"></span><br><span class="line">DestroyList(&amp;L) <span class="comment">//删除一个线性表</span></span><br><span class="line"></span><br><span class="line">ClearList(&amp;L) <span class="comment">//将L置为空表</span></span><br><span class="line"></span><br><span class="line">ListEmpty(L) <span class="comment">//线性表判空，空则返回true 不空false</span></span><br><span class="line"></span><br><span class="line">ListLength(L) <span class="comment">//返回线性表元素个数</span></span><br><span class="line"></span><br><span class="line">GetElem(L,i,&amp;e) <span class="comment">//用e返回第i个元素的值</span></span><br><span class="line"></span><br><span class="line">LocateElem(L,e) <span class="comment">//返回线性表L中第一个元素值与e相同元素的位置</span></span><br><span class="line"> </span><br><span class="line">ListInsert(&amp;L,i,e) <span class="comment">//在线性表L的第i个位置前插入元素e，L长度加一</span></span><br><span class="line"></span><br><span class="line">ListDelete(&amp;L,i) <span class="comment">//在线性表L删除第i位置的元素，L长度减一</span></span><br><span class="line"></span><br><span class="line">TraverseList(L) <span class="comment">//在线性表L中进行遍历，在遍历过程中对L的每个节点访问一次</span></span><br></pre></td></tr></table></figure><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><p>顺序表是用一组连续的地址单元空间存储线性表的数据元素</p><p>线性表的存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType elem <span class="comment">//元素基地址</span></span><br><span class="line"><span class="type">int</span> len <span class="comment">//当前长度</span></span><br><span class="line">&#125;Sqlist <span class="comment">//线性表类型</span></span><br></pre></td></tr></table></figure><h2 id="顺序表的基本操作实现"><a href="#顺序表的基本操作实现" class="headerlink" title="顺序表的基本操作实现"></a>顺序表的基本操作实现</h2><h3 id="顺序表建立"><a href="#顺序表建立" class="headerlink" title="顺序表建立"></a>顺序表建立</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">InitList</span><span class="params">(&amp;L)</span>&#123;</span><br><span class="line">L.elem=new ElemType(MAXSIZE);</span><br><span class="line"><span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">L.len=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取顺序表值"><a href="#取顺序表值" class="headerlink" title="取顺序表值"></a>取顺序表值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">GetElem</span><span class="params">(L,i,&amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||L.len&lt;i) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判断i是否合法</span></span><br><span class="line">e=L.elem[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表查找元素"><a href="#顺序表查找元素" class="headerlink" title="顺序表查找元素"></a>顺序表查找元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">LocateElem</span><span class="params">(L,e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e==L.elem[i]) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">retrun <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">ListInsert</span><span class="params">(&amp;L,i,e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L.len) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(L.len==MAXSIZE) reutrn ERROR;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L.len<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">&#125;</span><br><span class="line">L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">++L.len;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br></pre></td></tr></table></figure><p>顺序表的插入的时间复杂度为o(n)</p><h3 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">ListDelete</span><span class="params">(&amp;L,i)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;L.len||i&lt;<span class="number">0</span>) retrun ERROR;</span><br><span class="line"><span class="keyword">if</span>(L.len==<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.len;j++)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[i<span class="number">-1</span>]=L.elem[i];</span><br><span class="line">&#125;</span><br><span class="line">--L.len;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序表的删除时间复杂度为o(n)</p><h3 id="顺序表的遍历"><a href="#顺序表的遍历" class="headerlink" title="顺序表的遍历"></a>顺序表的遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">TraverseList</span><span class="params">(L)</span>&#123;</span><br><span class="line"><span class="type">int</span> e=get; <span class="comment">//遍历标志</span></span><br><span class="line"><span class="keyword">if</span>(L.len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.len;i++)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[i]=e; <span class="comment">//遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK; <span class="comment">//遍历成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表的存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElemType data; <span class="comment">//节点数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>； //节点的指针域</span></span><br><span class="line"><span class="class">&#125;<span class="title">LNode</span>,*<span class="title">LinkList</span>;</span> <span class="comment">//LinkList为指向结构体LNode的指针类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h3><p>单链表初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L=new LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    LNode p=new LNode;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;i||p)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;i||!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表按值查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status *<span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode p=new LNode;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表的插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status *<span class="title function_">insertElem</span><span class="params">(LinkList &amp;L,ElemType e,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    LNode p=new LNode;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LNode s=new LNode;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表的删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Status *<span class="title function_">deleteElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    LNode p=new LNode;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-2</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-2</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LNode s=new LNode;</span><br><span class="line">    s=p-&gt;next;</span><br><span class="line">    p-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建单链表</p><ol><li><p>前插法创建单链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status *<span class="title">createElemqian</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    LNode L=<span class="keyword">new</span> Node;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        LNode p=<span class="keyword">new</span> LNode;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后插法创建单链表</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status *<span class="title">createElemhou</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    LNode L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    LNode p=L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        LNode s=<span class="keyword">new</span> LNode;</span><br><span class="line">        cin&gt;&gt;s-&gt;data;</span><br><span class="line">        s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=s;</span><br><span class="line">        p=s; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是另一种形式的链式存储结构，其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。</p><p>将两个循环链表合成一个表</p><p>![img](file:&#x2F;&#x2F;&#x2F;C:\Users\lenovo\Documents\Tencent Files\523785331\Image\C2C\EFDEB4602FE683000E52CED5A8A46312.jpg)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LNode p=<span class="keyword">new</span> LNode;</span><br><span class="line">p=B-&gt;next-&gt;next;</span><br><span class="line">B-&gt;next=A-&gt;next;</span><br><span class="line">A-&gt;next=p;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表节点存在两个指针域，分别为前驱和后继，可描述如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DuLNode</span>&#123;</span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> *prior; <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> *next; <span class="comment">//后继指针</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure><h3 id="双向链表的基本操作的实现"><a href="#双向链表的基本操作的实现" class="headerlink" title="双向链表的基本操作的实现"></a>双向链表的基本操作的实现</h3><p>双向链表的插入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    DuLNode p=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    p=<span class="built_in">GetElem_Dul</span>(L,i);<span class="comment">//将p指向节点i</span></span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    DuLNode s=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;perior=s;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    s-&gt;perior=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向链表的删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_Dul</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    DuLNode p=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    p=<span class="built_in">GetElem_Dul</span>(L,i);<span class="comment">//将p指向节点i</span></span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;perior-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;perior=p-&gt;perior;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;perior=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F765%2Fa1f8aa464410a9978ce80c6205a037f5.png&refer=http%3A%2F%2Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648902451&t=f73a2c810b9407faf0f5cfc788683e5d" alt="图"></p><p>存储密度&#x3D;数据元素本身占用的存储量&#x2F;结点结构占用的存储量</p><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="线性表的合并"><a href="#线性表的合并" class="headerlink" title="线性表的合并"></a>线性表的合并</h3><p>已知存在A,B两个表，要将这两个表合成一个表（不能创造新的表）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(List &amp;LA,List LB)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m=<span class="built_in">ListLength</span>(LA);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">ListLength</span>(LB);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">GetELem</span>(LB,i,e);<span class="comment">//将LB第i个元素的值赋值给e</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(LA,e)) <span class="built_in">InsertElem</span>(LA,++m,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序有序表的合并"><a href="#顺序有序表的合并" class="headerlink" title="顺序有序表的合并"></a>顺序有序表的合并</h3><p>已知存在A,B两个顺序有序表，要将A,B两个表合成为C表，c表也是顺序有序表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_youxu</span><span class="params">(List LA,List LB)</span></span>&#123;</span><br><span class="line">    NodeList LC=<span class="keyword">new</span> NodeList;</span><br><span class="line">    <span class="built_in">initList</span>(LC);</span><br><span class="line">    x=<span class="built_in">ListLength</span>(LC);</span><br><span class="line">    n=<span class="built_in">ListLength</span>(LA);</span><br><span class="line">    m=<span class="built_in">ListLength</span>(LB);</span><br><span class="line">    *p=LA;</span><br><span class="line">    *s=LB;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.elem[i]&lt;s.elem[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">InsertElem</span>(LC,++x,p.elem[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">InsertElem</span>(LC,++x,s.elem[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) </span><br><span class="line">        <span class="keyword">while</span>(s)&#123;</span><br><span class="line">            <span class="built_in">InsertElem</span>(LC,++x,s.elem[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="built_in">InsertElem</span>(LC,++x,p.elem[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式有序表的合并"><a href="#链式有序表的合并" class="headerlink" title="链式有序表的合并"></a>链式有序表的合并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_L</span><span class="params">(LNodeList LA,LNodeList LB)</span></span>&#123;</span><br><span class="line">    pa=LA-&gt;next;</span><br><span class="line">    pb=LB-&gt;next;</span><br><span class="line">    LC=LA;</span><br><span class="line">    pc=LC;</span><br><span class="line">    <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pa;</span><br><span class="line">            pc=pa;</span><br><span class="line">            pa=pa-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pb;</span><br><span class="line">            pc=pb;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next=pa?pa:pb;</span><br><span class="line">    <span class="keyword">delete</span> LB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单项表，循环链表，双向表的比较"><a href="#单项表，循环链表，双向表的比较" class="headerlink" title="单项表，循环链表，双向表的比较"></a>单项表，循环链表，双向表的比较</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20190922215812533.jpg%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dLWF81%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648905961&t=b795507138931ce5cc9628418bf4f8a6" alt="图片"></p><p>第二章搞完</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客排坑之路</title>
      <link href="/2022/02/28/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%8E%92%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/02/28/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%8E%92%E5%9D%91%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="问题-在给博客配音乐的时候出现问题"><a href="#问题-在给博客配音乐的时候出现问题" class="headerlink" title="问题 在给博客配音乐的时候出现问题"></a>问题 在给博客配音乐的时候出现问题</h1><h2 id="问题原因和解决办法"><a href="#问题原因和解决办法" class="headerlink" title="问题原因和解决办法"></a>问题原因和解决办法</h2><p>我先摆出问题</p><p><img src="/../img/wenti1.png" alt="问题一"></p><p><img src="/./img/wenti2.png" alt="问题二"></p><p>这可能是我最无可奈何的时候，因为看不懂问题所处在哪里，事先也没有备份文件，导致我重新配了一遍主题，通过排错知道了问题在——主题配置文件中</p><p>原因就出在我在配置主题文件中误改了搜索系统</p><p>原本butterfly主题中可以选择本地搜索或者algolia，butterfly文档中也有详细的介绍：<a href="https://butterfly.js.org/posts/ceeb73f/">butterfly主题文档</a></p><p>言归正传，我选择的是本地搜索系统，但是我改的是algolia，错误的将false改成了true，具体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Algolia search</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: false     &lt;- 这里（我错误的将false改为了true，而我应用的是本地搜索，所以报错了5555,查了好久/(ㄒoㄒ)/~~）</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 6</span><br></pre></td></tr></table></figure><p>把它改回来就解决了</p><p>然后在安装音乐过程中，由于我当时安装butterfly是用的npm方式，所以我要找的layout文件没有在theme目录下</p><p>该文件是在node_modules&#x2F;hexo-theme-butterfly文件下（找了好久555ㄒoㄒ）</p><p>然后我跟着csdn上的教程一步一步做，发现根本不用改layout.pug和aplayer.pug文件</p><p>但是之前安装命令还是必要的</p><h2 id="实现音乐功能"><a href="#实现音乐功能" class="headerlink" title="实现音乐功能"></a>实现音乐功能</h2><p>实现音乐功能如下：</p><p>先定位到blog文件下，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new page music</span><br><span class="line"></span><br><span class="line">npm install aplayer</span><br><span class="line"></span><br><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>之后打开你博客根目录下的_config.yml，在最后添加以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#aplayer</span><br><span class="line">aplayer: </span><br><span class="line">  script_dir: js                      # Public 目录下脚本目录路径，默认: &#x27;assets/js&#x27;</span><br><span class="line">  style_dir: css                         # Public 目录下样式目录路径，默认: &#x27;assets/css&#x27;</span><br><span class="line">  #cdn: http://xxx/aplayer.min.js                # 引用 APlayer.js 外部 CDN 地址 (默认不开启)</span><br><span class="line">  #style_cdn: http://xxx/aplayer.min.css         # 引用 APlayer.css 外部 CDN 地址 (默认不开启)</span><br><span class="line">  meting: true                                  # MetingJS 支持</span><br><span class="line">  #meting_api: http://xxx/api.php                # 自定义 Meting API 地址</span><br><span class="line">  #meting_cdn: http://xxx/Meing.min.js           # 引用 Meting.js 外部 CDN 地址 (默认不开启)</span><br><span class="line">  asset_inject: true                            # 自动插入 Aplayer.js 与 Meting.js 资源脚本, 默认开启</span><br><span class="line">  #externalLink: http://xxx/aplayer.min.js       # 老版本参数，功能与参数 cdn 相同meting: true</span><br></pre></td></tr></table></figure><p>并在_config.yml调整post_asset_folder如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>最后一步在博客根目录\source\music\index.md使用以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的歌单</span><br><span class="line">date: 2019-05-17 16:14:00</span><br><span class="line">cover: https://cdn.jsdelivr.net/gh/radium-bit/res@latest/Music.jpg</span><br><span class="line">type: &quot;music&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;font color=#0c74d6 size=3 face=&quot;黑体&quot;&gt;**这是歌单介绍，如果不需要刻意留空**&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&#123;% meting &quot;697054881&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;   // 这一行请查看文档自行修改</span><br></pre></td></tr></table></figure><p>那一串数字是歌单ID，“netease”为网易云音乐。详细参数用法请参考<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">官方文档</a><br>歌单ID提取方法是以链接分享某个歌单<br>例如<br><a href="https://music.163.com/playlist?id=313418853&amp;userid=1362990007">https://music.163.com/playlist?id=313418853&amp;userid=1362990007</a></p><p>313418853就是歌单ID了</p><p>写入完毕后，在博客根目录下输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成完毕！最后差不多是这样：<br><img src="/./img/jieguo1.png" alt="问题一"></p><p>我真的搞了好久，这种问题真的是太致命了，长个记性，下次改文件之前需要先备份一份</p><p>得去回回血了枯😭</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客排坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/28/hello-world/"/>
      <url>/2022/02/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客心得</title>
      <link href="/2022/02/23/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"/>
      <url>/2022/02/23/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="搭建前提"><a href="#搭建前提" class="headerlink" title="搭建前提"></a>搭建前提</h2><ul><li>需要安装git</li><li>需要安装Node.js</li><li>需要安装Hexo</li></ul><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。<a href="https://www.liaoxuefeng.com/wiki/896043488029600">git教程</a></p><p>windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。<br>git官网链接：<a href="https://git-scm.com/">https://git-scm.com</a></p><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h2><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：nodejs选择LTS版本就行了。<br>官网地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>linux：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装完后，打开git bash命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h2><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>利用’hexo -v’查看一下版本</p><p>安装就此完成</p><h2 id="4-查看成果"><a href="#4-查看成果" class="headerlink" title="4.查看成果"></a>4.查看成果</h2><p>首先初始化一下hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><p>这个myblog可以自己取什么名字都行，然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p>在git bash中输入以下命令打开你自己生成的博客了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>大概长这个样子<br><img src="https://monster-zero.github.io/newlife.github.io/person/23.png"></p><p>至此博客就在本地搭建完成啦！</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
