<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构第五章</title>
      <link href="/2022/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>/2022/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第五章"><a href="#数据结构第五章" class="headerlink" title="数据结构第五章"></a>数据结构第五章</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是n(n&gt;&#x3D;0)个节点的有限集，它或为空树(n&#x3D;0)；或称为非空树，对于非空树T</p><ul><li>有且只有一个根节点</li><li>除根以外的节点可分为m（m&gt;0）个互不相交的有限集，其中每个集合本身又是一棵树，并且称为根的子树。</li></ul><p>非空树的特性</p><ol><li>有且只有一个根节点</li><li>没有后继节点称为叶子节点</li><li>有后继的节点称为分支节点</li><li>除根节点外，任何一个节点有且只有一个前驱</li><li>每个节点可以有0或多个后继</li><li>根节点的子树互不相交</li></ol><p>除此以外，还有一些必要的知识</p><p>节点的度：有几个孩子</p><p>树的度：各个节点的度的最大值</p><p>树的高度：指树共有多少层</p><p>兄弟：指同一个双亲的孩子之间互称兄弟</p><p>堂兄弟：双亲在同一层的节点互为堂兄弟</p><p>树的深度：树中结点的最大层次称为树的深度和高度</p><p>有序树和无序树：如果树中结点的各个子树看成从左至右是有次序的（即不能互换）则称为该树为有序树，否则为无序树</p><p>森林：是m课互不相交的树的集合</p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树是n个结点所构成的集合，它或为空树，或为非空树，与树不同的是</p><ul><li>除根结点之外，其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树</li><li>二叉树每个结点至多只有两棵子树</li><li>二叉树的子树有左右之分，其次序不能任意颠倒</li></ul><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>一个二叉树，如果每一层的二叉树的节点数到达最大值，则被称为满二叉树</p><ul><li>只有最后一层有叶子节点</li><li>不存在度为1的节点</li><li>按层序从一开始编号节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为$\lfloor i&#x2F;2 \rfloor$ (如果存在)</li><li>总节点数为$2^n-1$</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时为完全二叉树</p><ul><li>只有最后两层可能有叶子结点</li><li>最后只有一个度为1的结点</li><li>按层序从一开始编号节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为$\lfloor i&#x2F;2 \rfloor$ (如果存在)</li><li>i&lt;&#x3D;$\lfloor n&#x2F;2 \rfloor$ 为分支节点，i&gt;$\lfloor n&#x2F;2 \rfloor$ 为叶子节点</li></ul><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>左子树上所有节点的关键字均小于根节点</p><p>右子树上的所有结点的关键字大于根节点</p><p><em>注意</em></p><ol><li>二叉树第i层，至多有 2^i-1^ 个节点，m叉树第i层至多有m^i-1^ 个节点</li><li>高度为h的二叉树至多有2^n-1^ 个节点，高度为h的m叉树至多有 (m^h^ -1)&#x2F;(m-1)个节点</li><li>具有n个（n&gt;0）的结点的完全二叉树的高度h为 $\lceil log_2n\rceil+1$</li></ol><h2 id="树和二叉树的抽象类型定义"><a href="#树和二叉树的抽象类型定义" class="headerlink" title="树和二叉树的抽象类型定义"></a>树和二叉树的抽象类型定义</h2><p>定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT Tree&#123;</span><br><span class="line">    <span class="built_in">InitTree</span>(&amp;T) <span class="comment">//构造空树</span></span><br><span class="line">    <span class="built_in">DestroyTree</span>(&amp;T) <span class="comment">//销毁树T</span></span><br><span class="line">    <span class="built_in">CreateTree</span>(&amp;T,definition) <span class="comment">//按definition构造树T</span></span><br><span class="line">    <span class="built_in">ClearTree</span>(&amp;T) <span class="comment">//将树清为空树</span></span><br><span class="line">    <span class="built_in">TreeEmpty</span>(T) <span class="comment">//判断树是否为空树，为空则返回true，否则返回false</span></span><br><span class="line">    <span class="built_in">TreeDepth</span>(T) <span class="comment">//返回树的深度</span></span><br><span class="line">    <span class="built_in">Root</span>(T) <span class="comment">//返回树的根节点</span></span><br><span class="line">    <span class="built_in">Value</span>(T,cur_e) <span class="comment">//返回cur_e的值</span></span><br><span class="line">    <span class="built_in">Assign</span>(T,cur_e,value) <span class="comment">//给cur_e赋值为value</span></span><br><span class="line">    <span class="built_in">Parent</span>(T,cur_e) <span class="comment">//返回cur_e的双亲结点，否则返回值为空</span></span><br><span class="line">    <span class="built_in">LeftChild</span>(T,cur_e) <span class="comment">//若cur_e为非叶子节点，则返回它的左孩子节点，否则返回为空</span></span><br><span class="line">    <span class="built_in">RightChild</span>(T,cur_e) <span class="comment">//若cur_e为非叶子节点，则返回它的右孩子节点，否则返回为空</span></span><br><span class="line">    <span class="built_in">RightSibling</span>(T,cur_e) <span class="comment">//若cur_e有右兄弟，则返回它的右兄弟，否则函数值为空</span></span><br><span class="line">    <span class="built_in">InsertChild</span>(&amp;T,p,i,c) <span class="comment">//插入c为T中p指节点的第i棵子树</span></span><br><span class="line">    <span class="built_in">DeleteChild</span>(&amp;T,p,i) <span class="comment">//删除T中p指节点的第i棵子树</span></span><br><span class="line">    <span class="built_in">TraverseTree</span>(T) <span class="comment">//按某种次序对T的每个节点访问一遍</span></span><br><span class="line">&#125;ADT Tree</span><br></pre></td></tr></table></figure><p>二叉树定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ADT BinaryTree&#123;</span><br><span class="line">    <span class="built_in">InitBiTree</span>(&amp;T) <span class="comment">//构造空树</span></span><br><span class="line">    <span class="built_in">DestroyBiTree</span>(&amp;T) <span class="comment">//销毁树T</span></span><br><span class="line">    <span class="built_in">CreateBiTree</span>(&amp;T,definition) <span class="comment">//按definition构造树T</span></span><br><span class="line">    <span class="built_in">ClearBiTree</span>(&amp;T) <span class="comment">//将树清为空树</span></span><br><span class="line">    <span class="built_in">BiTreeEmpty</span>(T) <span class="comment">//判断树是否为空树，为空则返回true，否则返回false</span></span><br><span class="line">    <span class="built_in">BiTreeDepth</span>(T) <span class="comment">//返回树的深度</span></span><br><span class="line">    <span class="built_in">Root</span>(T) <span class="comment">//返回树的根节点</span></span><br><span class="line">    <span class="built_in">Value</span>(T,cur_e) <span class="comment">//返回cur_e的值</span></span><br><span class="line">    <span class="built_in">Assign</span>(T,cur_e,value) <span class="comment">//给cur_e赋值为value</span></span><br><span class="line">    <span class="built_in">Parent</span>(T,cur_e) <span class="comment">//返回cur_e的双亲结点，否则返回值为空</span></span><br><span class="line">    <span class="built_in">LeftChild</span>(T,cur_e) <span class="comment">//若cur_e为非叶子节点，则返回它的左孩子节点，否则返回为空</span></span><br><span class="line">    <span class="built_in">RightChild</span>(T,cur_e) <span class="comment">//若cur_e为非叶子节点，则返回它的右孩子节点，否则返回为空</span></span><br><span class="line">    <span class="built_in">LeftSibling</span>(T,cur_e) <span class="comment">//若cur_e有左兄弟，则返回它的左兄弟，否则函数值为空</span></span><br><span class="line">    <span class="built_in">RightSibling</span>(T,cur_e) <span class="comment">//若cur_e有右兄弟，则返回它的右兄弟，否则函数值为空</span></span><br><span class="line">    ★<span class="built_in">InsertChild</span>(&amp;T,p,LR,c) <span class="comment">//根据LR的值为0或1，插入c为T中p所指结点的左或右子树，p所指结点的原有左或右子树则成c的右子树</span></span><br><span class="line">    <span class="built_in">DeleteChild</span>(&amp;T,p,i) <span class="comment">//删除T中p指节点的第i棵子树</span></span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T) <span class="comment">//先序遍历二叉树T</span></span><br><span class="line">    <span class="built_in">InorderTraverse</span>(T) <span class="comment">//中序遍历二叉树T</span></span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T) <span class="comment">//后序遍历二叉树T</span></span><br><span class="line">    <span class="built_in">LevelOrderTraverse</span>(T) <span class="comment">//层序遍历二叉树T</span></span><br><span class="line">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h3><p>二叉树在第i层至多有2^i-1^ 个结点。</p><h3 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h3><p>深度为i的二叉树至多有2^i^-1个结点。</p><h3 id="性质三"><a href="#性质三" class="headerlink" title="性质三"></a>性质三</h3><p>如果一颗二叉树终端结点为$n_0$ ,度为2的点数为$n_2$ ,则有公式$n_0&#x3D;n_2+1$</p><p> 性质三证明：</p><p>设度为1的结点树为$n_1$ ,n为结点总数，因为二叉树的结点度小于等于2，则有下面公式</p><p>① $$ n&#x3D;n_0+n_1+n_2$$ </p><p>设B为分支总数，则有下面公式</p><p>②$$n&#x3D;B+1$$ </p><p>③$$B&#x3D;n_1+2n_2$$ </p><p>将两式合并能求得</p><p>④$$n&#x3D;n_1+2n_2+1$$ </p><p>再将①④式合并得</p><p>$$n_0&#x3D;n_2+1$$</p><h3 id="性质四"><a href="#性质四" class="headerlink" title="性质四"></a>性质四</h3><p>具有n个结点的完全二叉树的深度为$\lfloor log_2n \rfloor+1$</p><h3 id="性质五"><a href="#性质五" class="headerlink" title="性质五"></a>性质五</h3><p>如果一颗具有n个结点的完全二叉树的结点按照层序编号（从第1层到第$\lfloor log_2n \rfloor+1$ 层，每层从左至右），则对任一结点i有</p><ol><li>若i&#x3D;1，则为根节点，若i&gt;1,则双亲结点为$\lfloor i&#x2F;2 \rfloor$ </li><li>若2i&gt;n,则结点i无左孩子，否则左孩子结点为2i</li><li>若2i+1&gt;n,则结点i无右孩子，否则右孩子结点为2i+1</li></ol><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><p>顺序存储：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBitree[MAXSIZE];</span><br><span class="line">SqBitree bt;</span><br></pre></td></tr></table></figure><p>链式存储：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h3 id="遍历二叉树的方法"><a href="#遍历二叉树的方法" class="headerlink" title="遍历二叉树的方法"></a>遍历二叉树的方法</h3><ol><li><p>先序遍历</p><p>按照根、左、右的顺序遍历</p></li><li><p>中序遍历</p><p>按照左、根、右的顺序遍历</p></li><li><p>后序遍历</p><p>按照左、右、根的顺序遍历</p></li><li><p>层序遍历</p><p>按照层数从小到大，从左到右进行遍历</p></li></ol><p><em>注意</em></p><p>先序，中序，后序遍历运用了栈的数据结构，主要思想就是按照先左子树后右子树的顺序依次遍历树中各个结点。</p><p>层序遍历运用了队列的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。</p><h3 id="遍历代码实现"><a href="#遍历代码实现" class="headerlink" title="遍历代码实现"></a>遍历代码实现</h3><p>这里实现中序遍历，其他遍历就不一 一列举了</p><p>递归中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">InorderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">        <span class="built_in">InorderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    p=T;</span><br><span class="line">    q=<span class="keyword">new</span> BiNode;</span><br><span class="line">    <span class="keyword">while</span>(p||<span class="built_in">EmptyStack</span>(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="built_in">push</span>(S,p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Pop</span>(S,q);</span><br><span class="line">            cout&lt;&lt;q-&gt;data;</span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h3><p>由二叉树遍历确定二叉树序列，</p><ol><li><p>若知道先序，中序，后序，层序其中的四种或者三种，可确定唯一二叉树的序列</p></li><li><p>若知道先序，中序，后序，层序其中的两种，分两种情况：</p><p>①当知道中序和先序，中序和后序，中序和层序随机的一组时，可确定唯一的二叉树的序列</p><p>②当先序，后序，层序两两随意组合时无法唯一确定一棵二叉树序列</p></li><li><p>若知道先序，中序，后序，层序其中的任意一种时，无法唯一确定二叉树的序列</p></li></ol><h3 id="二叉树遍历算法的应用"><a href="#二叉树遍历算法的应用" class="headerlink" title="二叉树遍历算法的应用"></a>二叉树遍历算法的应用</h3><h4 id="算法一-先序遍历的顺序建立二叉链表"><a href="#算法一-先序遍历的顺序建立二叉链表" class="headerlink" title="算法一 先序遍历的顺序建立二叉链表"></a>算法一 先序遍历的顺序建立二叉链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>) T=NUll;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法二-复制二叉树"><a href="#算法二-复制二叉树" class="headerlink" title="算法二 复制二叉树"></a>算法二 复制二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(BiTree T,BiTree &amp;newT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newT=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        newT=<span class="keyword">new</span> BiNode;</span><br><span class="line">        newT-&gt;data=T-&gt;data;</span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;lchild,newT-&gt;rchild);</span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;rchild,newT-&gt;rchild);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法三-计算二叉树的深度"><a href="#算法三-计算二叉树的深度" class="headerlink" title="算法三 计算二叉树的深度"></a>算法三 计算二叉树的深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        m=<span class="built_in">Depth</span>(T-&gt;lchild)+<span class="number">1</span>;</span><br><span class="line">        n=<span class="built_in">Depth</span>(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法四-统计二叉树的结点个数"><a href="#算法四-统计二叉树的结点个数" class="headerlink" title="算法四 统计二叉树的结点个数"></a>算法四 统计二叉树的结点个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">NodeCount</span>(T-&gt;lchild)+<span class="number">1</span>+<span class="built_in">NodeCount</span>(T-&gt;rchild)+<span class="number">1</span>+<span class="number">1</span>;<span class="comment">//NodeCount(T-&gt;lchild)+1代表左孩子个数，NodeCount(T-&gt;rchild)+1代表右孩子个数，最后+1代表根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h2><p>线索二叉树的概念（来自百度嘿嘿(￣︶￣*))</p><p><img src="D:\blog\source\img\erchashu.png" alt="image-20220322152137888"></p><p>总结来说，因为当以二叉链表作为存储结构时，只能找到结点的左右孩子信息，而无法找到前驱和后继信息，而且n个结点也存在n+1个空链域，正好用来做前驱和后继指针</p><p>试做如下规定：若结点有左子树，则其lchild指示其左孩子，否则令lchild域指示其前驱，若结点有右子树，则其rchild指示其右孩子，否则令rchild指示其后继，为了区分，增加两个标志域LTag和RTag，</p><p>$$ LTag&#x3D;\left{ \begin{matrix} 0&#x2F;&#x2F;lchild域指向结点的左孩子  \ 1&#x2F;&#x2F;lchild域指向结点的前驱  \end{matrix} \right. $$</p><p>$$ RTag&#x3D;\left{ \begin{matrix} 0&#x2F;&#x2F; Rchild域指向结点的右孩子  \ 1&#x2F;&#x2F;Rchild域指向结点的后继  \end{matrix} \right.$$</p><p>二叉线索存储表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiThrNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiThrNode</span> *lchild,*rchild;</span><br><span class="line">    <span class="type">int</span> LTag,RTag;</span><br><span class="line">&#125;BiThrNode,*BiThree;</span><br></pre></td></tr></table></figure><h3 id="二叉树的中序线索化"><a href="#二叉树的中序线索化" class="headerlink" title="二叉树的中序线索化"></a>二叉树的中序线索化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inthreading</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="comment">//pre代表结点前驱，p代表结点后继</span></span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">Inthreading</span>(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild)&#123;</span><br><span class="line">            LTag=<span class="number">1</span>;</span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;Tag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;rchild)&#123;</span><br><span class="line">            RTag=<span class="number">1</span>;</span><br><span class="line">            pre-&gt;rchild=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> pre-&gt;rchild=<span class="number">0</span>;</span><br><span class="line">        pre=p;</span><br><span class="line">        <span class="built_in">InThreading</span>(pre-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带头结点的二叉树中序线索化"><a href="#带头结点的二叉树中序线索化" class="headerlink" title="带头结点的二叉树中序线索化"></a>带头结点的二叉树中序线索化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderThreading</span><span class="params">(BiTree &amp;Thrt,BiTrTree T)</span></span>&#123;</span><br><span class="line">    Thrt=<span class="keyword">new</span> ThBiNode;</span><br><span class="line">    Thrt-&gt;LTag=<span class="number">0</span>;</span><br><span class="line">    Thrt-&gt;RTag=<span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;rchild=Thrt;</span><br><span class="line">    <span class="keyword">if</span>(!T) Thrt-&gt;lchild=Thrt;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Thrt-&gt;lchild=T;</span><br><span class="line">        pre=Thrt;</span><br><span class="line">        <span class="built_in">InThreading</span>(T);</span><br><span class="line">        pre-&gt;rchild=Thrt;</span><br><span class="line">        pre-&gt;RTag=<span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rchild=pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树如何查找结点的前驱和后继"><a href="#遍历二叉树如何查找结点的前驱和后继" class="headerlink" title="遍历二叉树如何查找结点的前驱和后继"></a>遍历二叉树如何查找结点的前驱和后继</h3><p>分三种情况：</p><ol><li><p>在中序线索二叉树下查找：</p><p>1). 查找结点p的前驱时：</p><p>当p-&gt;LTag&#x3D;1时 p的左链指向前驱。</p><p>当p-&gt;LTag&#x3D;0时，代表p有左子树，p的前驱结点就是遍历左子树最后一个结点即左子树右下结点。</p><p>2).查找结点p的后继时：</p><p>当p-&gt;RTag&#x3D;1时 p的右链指向后继。</p><p>当p-&gt;RTag&#x3D;0时，代表p有右子树，则p的后继结点是遍历右子树第一个结点即右子树左下结点。</p></li><li><p>在先序线索二叉树下查找：</p><p>1).查找结点p的前驱时：</p><p>当p-&gt;LTag&#x3D;1时 p的左链指向前驱。</p><p>当p-&gt;LTag&#x3D;0时，则p的前驱结点为其双亲结点。</p><p>2).查找结点p的后继时:</p><p>当p-&gt;RTag&#x3D;1时，p的右链指向后继。</p><p>当p-&gt;RTag&#x3D;0时，即p有右子树时，当p-&gt;LTag&#x3D;0时，p的后继为左子树的根节点，当p-&gt;LTag&#x3D;1时，则p的后继为右子树的根节点。</p></li><li><p>在后序线索二叉树下查找：</p><p>1).查找结点p的前驱时：</p><p>当p-&gt;LTag&#x3D;1时 p的左链指向前驱。</p><p>当p-&gt;LTag&#x3D;0时，即p有左子树时，当p-&gt;RTag&#x3D;1时，p的前驱结点为左子树的根节点，当p-&gt;RTag&#x3D;0时，即存在右子树时，p的前驱结点为右子树的根节点。</p><p>2).查找结点p的后继时，分情况讨论：</p><p>当*p为根节点时，无后继结点。</p><p>当*p为右孩子结点时，后继结点为双亲结点。</p><p>当*p为左孩子结点时，当无右兄弟结点时，后继结点为双亲结点。</p><p>当*p为左孩子结点时，当存在右兄弟结点时，后继结点为右兄弟遍历的第一个结点，即左下结点。</p></li></ol><h3 id="遍历中序二叉树"><a href="#遍历中序二叉树" class="headerlink" title="遍历中序二叉树"></a>遍历中序二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    p=T-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;LTag==<span class="number">0</span>) p=p-&gt;lchild;</span><br><span class="line">        cout&lt;&lt;p-&gt;data;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;RTag==<span class="number">1</span>&amp;&amp;p-&gt;rchild!=T)&#123;</span><br><span class="line">            p=p-&gt;child;</span><br><span class="line">            cout&lt;&lt;p-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ol><li><p>双亲表示法</p><p>以一组连续的存储单元结构树的结点，每个结点除了数据域data之外，还附带了一个parent域用来指示其双亲结点的位置</p></li><li><p>孩子表示法</p><p>由于树可能含有多颗子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向子树的根节点。</p></li><li><p>孩子兄弟表示法</p><p>又称二叉链表表示法，即以二叉链表做树的存储结构，包括数据域和两个链域，一个链域指向该结点的第一个孩子，另一个链域指向该结点孩子的兄弟结点。</p><p>表示方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild,*nextchild;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure></li></ol><p>森林和二叉树的转换</p><p>森林转化为二叉树：</p><p>如果F&#x3D;{$T_1,T_2,…,T_m$} 是森林，则可按如下规则转化成一颗二叉树B&#x3D;(root,LB,RB);</p><p>1.若F为空，即m&#x3D;0，则B为空树。</p><p>2.若F非空，即m$$\ne$$0时，B的根是森林中第一棵树的根ROOT($T_1$)，左子树就是$T_1$根节点的子树森林转换而成的二叉树，其右子树就是森林{$T_2,T_3,…,T_M$}转换而成的二叉树。</p><p>二叉树转化成森林：</p><p>将上述操作逆向进行。</p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p>若森林非空</p><p>  1.先序遍历森林</p><p>  1).访问第一棵树的根节点。</p><p>  2).先序遍历第一棵树的根节点的子树森林。</p><p>  3).先序遍历除第一颗树以外构成的森林。</p><p>  2.中序遍历森林</p><p>  1).中序遍历第一颗树的根节点的子树森林。</p><p>  2).访问第一颗树的根节点。</p><p>  3).中序遍历除第一颗树以外构成的森林。</p><h2 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="headerlink" title="哈夫曼树及其应用"></a>哈夫曼树及其应用</h2><p>哈夫曼树又称最优树，是一类带权路径长度最短的树。下面有几个概念需要提前了解</p><p>路径：从树的一个结点到另一个结点构成的分支叫做路径</p><p>路径长度：路径上的分支数目叫做路径长度</p><p>树的路径长度：从树根到每一结点的路径之和</p><p>权：赋予某个实体的一个量，是对实体的某个或某些属性的数值进行描述。</p><p>结点的带权路径长度：从该结点到根节点的路径长度乘以该节点的权值。</p><p>树的带权路径长度：树的所有叶子结点的带权路径长度之和，通常记作WPL。</p><h3 id="哈夫曼的构造算法"><a href="#哈夫曼的构造算法" class="headerlink" title="哈夫曼的构造算法"></a>哈夫曼的构造算法</h3><ol><li>根据n个权值的结点构成n棵只有根结点的二叉树，这n棵树构成森林F。</li><li>在这个森林里选择两个权值最小的树作为左右子树构成一颗新二叉树，并且其根节点的权值为左右子树权值的和。</li><li>去掉森林中这两棵树，并且同时把新构成的树加入森林。</li><li>重复2和3，知道F只含有一颗树时，这棵树则是哈夫曼树。</li></ol><h3 id="哈夫曼算法的实现"><a href="#哈夫曼算法的实现" class="headerlink" title="哈夫曼算法的实现"></a>哈夫曼算法的实现</h3><p>哈夫曼的存储表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> weight; </span><br><span class="line"><span class="type">int</span> parent,lchild,rchild;</span><br><span class="line">&#125;HTNode,*HuffmanTree;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第四章</title>
      <link href="/2022/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2022/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第四章"><a href="#数据结构第四章" class="headerlink" title="数据结构第四章"></a>数据结构第四章</h1><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><p>串是由零个或多个字符组成的有限序列，一般记为</p><p>$$s&#x3D;”a_1a_2…a_n”(n&gt;&#x3D;0)$$ </p><p>串中字符数目n称为串的长度，零个字符的串称为空串，其长度为零</p><p>串中任意个连续的字符组成的子序列称为该串的子串</p><p>称两个串相等的，当且仅当这两个串的值相等</p><p>由一个或多个空格组成的串称为空格串</p><p>串的前缀：包括第一个字符且不包含最后一个字符的子串</p><p>串的后缀：包含最后一个字符，且不包含第一个字符的子串</p><h3 id="串的类型定义"><a href="#串的类型定义" class="headerlink" title="串的类型定义"></a>串的类型定义</h3><p>串的类型定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT String&#123;</span><br><span class="line">    <span class="built_in">StrAssign</span>(&amp;T,chars)<span class="comment">//生成一个其值等于chars的串T</span></span><br><span class="line">    <span class="built_in">StrEmpty</span>(S)<span class="comment">//若串为空则返回true，否则返回false</span></span><br><span class="line">    <span class="built_in">StrCompare</span>(S,T)<span class="comment">//若S&gt;T,则返回值&gt;0,若S=T,则返回值等于0，若S&lt;T,则返回值&lt;0</span></span><br><span class="line">    <span class="built_in">StrLength</span>(S) <span class="comment">//返回S的元素个数，称为串的长度</span></span><br><span class="line">    <span class="built_in">ClearString</span>(&amp;S) <span class="comment">//将S清为空串</span></span><br><span class="line">    <span class="built_in">Concat</span>(&amp;T,S1,S2) <span class="comment">//用T返回S1和S2连接的新串</span></span><br><span class="line">    <span class="built_in">SubString</span>(&amp;Sub,S,pos,len)<span class="comment">//用sub返回串S的第pos个字符起长度为len的子串</span></span><br><span class="line">    <span class="built_in">Index</span>(S,T,pos)<span class="comment">//若主串S中存在和串T相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回函数值为0</span></span><br><span class="line">    <span class="built_in">Replace</span>(&amp;S,T,V)<span class="comment">//用V替换所有出现在S中与T相等的子串</span></span><br><span class="line">    <span class="built_in">StrInsert</span>(&amp;S,pos,T)<span class="comment">//在S串第pos个字符前插入串T</span></span><br><span class="line">    <span class="built_in">StrDelete</span>(&amp;S,pos,len)<span class="comment">//从串S删除从第pos个字符起长度为len的子串</span></span><br><span class="line">    <span class="built_in">DestroyString</span>(&amp;S)<span class="comment">//销毁S</span></span><br><span class="line">&#125;ADT String</span><br></pre></td></tr></table></figure><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><h4 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h4><p>顺序存储结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><p>堆式顺序存储结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ch;<span class="comment">//若为非空串，则按串长分配存储空间，否则为null</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h4 id="串的链式存储结构："><a href="#串的链式存储结构：" class="headerlink" title="串的链式存储结构："></a>串的链式存储结构：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">chunk</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line">    Struct Chunk *next;</span><br><span class="line">&#125;chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    Chunk *head,*tail;</span><br><span class="line">    <span class="type">int</span> length; </span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><h3 id="串的匹配模式算法"><a href="#串的匹配模式算法" class="headerlink" title="串的匹配模式算法"></a>串的匹配模式算法</h3><p>BF算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">index_BF</span><span class="params">(SString S,SString T,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=pos,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[j]==S.ch[i])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kmp算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int_kmp</span>(SString S,SString T,<span class="type">int</span> pos)&#123;</span><br><span class="line">    <span class="type">int</span> i=pos,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=T.length&amp;&amp;i&lt;=S.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[j]==S.ch[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(SString T,<span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[i]==T.ch[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kmp算法的时间复杂度为o(n+m)</p><p>BF算法的时间复杂度为o(n*m)</p><p>kmp优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此处有点不懂，先不做处理<span class="built_in">O</span>(∩_∩)O</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>数组是由类型相同的数据元素构成的有序集合</p><h3 id="数组的类型定义"><a href="#数组的类型定义" class="headerlink" title="数组的类型定义"></a>数组的类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADT Array&#123;</span><br><span class="line">    <span class="built_in">InitArray</span>(&amp;A,boundi,...,boundn)<span class="comment">//r若维数n和各维长度合法，则构造相应的数组A，并返回OK</span></span><br><span class="line">    <span class="built_in">DestroyArray</span>(&amp;A)<span class="comment">//销毁数组A</span></span><br><span class="line">    <span class="built_in">Value</span>(A,&amp;e,index1,index2,...,indexn)<span class="comment">//若各下标不超界，则e赋值为所指定的A的元素值，返回OK</span></span><br><span class="line">    <span class="built_in">Assign</span>(&amp;A,e,index1,index2,...,indexn)<span class="comment">//若下标不超界，则e的值赋给所指定的A的元素值，返回OK    </span></span><br><span class="line">&#125;ADT Array</span><br></pre></td></tr></table></figure><p>矩阵的顺序存储和特殊矩阵的压缩存储</p><p>见书p99-p101</p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><h3 id="广义表的定义"><a href="#广义表的定义" class="headerlink" title="广义表的定义"></a>广义表的定义</h3><p>广义表是线性表的推广，也称为列表，一般记作：</p><p>$$LS&#x3D;(a_1,a_2,…,a_n)$$ </p><p>n表示为广义表的长度，$$a_i$$ 可以表示单个元素也可以作为广义表，分别称为广义表的原表和子表</p><h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><p>广义表中的元素有着不同的结构，所以难以用顺序表表示，通常用链式存储结构，常用的链式存储结构有两种：头尾链表的存储结构和扩展线性表的存储结构</p><h4 id="头尾链表的存储结构"><a href="#头尾链表的存储结构" class="headerlink" title="头尾链表的存储结构"></a>头尾链表的存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">enum</span><span class="params">(ATOM,LIST)</span> ElemTag</span>; <span class="comment">//ATOM==0:原子；LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GLNode</span>&#123;</span><br><span class="line">    ElemTag tag;<span class="comment">//公共部分，用于区分原子结点的表结点</span></span><br><span class="line">    <span class="keyword">union</span> <span class="comment">//原子结点和表结点的联合部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        AtomType atom;<span class="comment">//atom是原子结点的值域，AtomType由用户定义</span></span><br><span class="line">        <span class="keyword">struct</span>&#123;<span class="keyword">struct</span> <span class="title class_">GLNode</span>*hp,*tp;&#125;ptr;<span class="comment">//ptr是表结点的指针域，ptr.hp和ptr.tp分别指向表头和表尾</span></span><br><span class="line">    &#125;；</span><br><span class="line">&#125;*GList; <span class="comment">//广义表类型</span></span><br></pre></td></tr></table></figure><h2 id="案例分析与实现"><a href="#案例分析与实现" class="headerlink" title="案例分析与实现"></a>案例分析与实现</h2><p>病毒感染检验</p><p>现在要检测某种病毒的DNA序列是否在患者的DNA序列出现过，实际上就是字符串的模式匹配问题。</p><p>假设病毒DNA序列的长度为m，因为病毒是环状的，所以将病毒的序列扩大两倍，变为2m，将病毒的DNA序列存储两次，进行m次循环，依次取得m个病毒的序列，将人的DNA序列作为主串，利用BF算法跟m个病毒序列进行匹配比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Virus_detection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;in.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>)</span></span>;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">        inFile&gt;&gt;Virus.ch+<span class="number">1</span>;</span><br><span class="line">        inFile&gt;&gt;person.ch+<span class="number">1</span>;</span><br><span class="line">        data=Virus.ch;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        len=Virus.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len+<span class="number">1</span>,j=<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">            Virus.ch[i++]=Virus.ch[j];</span><br><span class="line">        virus[<span class="number">2</span>*len+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                temp.ch[j]=Virus[i+j];</span><br><span class="line">            &#125;</span><br><span class="line">            temp.ch[len+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            flag= <span class="built_in">index_BF</span>(person,temp,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            cout&lt;&lt;peson.ch+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;person.ch+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四章结束</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将博客部署到github</title>
      <link href="/2022/03/02/%E5%8D%9A%E5%AE%A2/%E5%B0%86%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/"/>
      <url>/2022/03/02/%E5%8D%9A%E5%AE%A2/%E5%B0%86%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h1><h2 id="什么是GitHub"><a href="#什么是GitHub" class="headerlink" title="什么是GitHub"></a>什么是GitHub</h2><p>GitHub是一个面向开源及私有软件项目的托管平台，功能杠杠的，这里我们就用到它的其中一个功能，免费部署静态网站。<a href="https://github.com/">GitHub</a></p><h2 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h2><ol><li>在GitHub官网<a href="https://link.zhihu.com/?target=https://github.com/">https://github.com/</a>注册账户并登陆。</li><li>创建一个新仓库(repository)，名称<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>，username是github用户名。然后依次进行下面四步操作：<ul><li>点击右上角的账户图标 </li><li>点击”Your profile” </li><li>点击”Repositories” </li><li>点击new</li></ul></li></ol><p><img src="https://pic3.zhimg.com/v2-f9644333b89cf932682cf495ddedd32e_r.jpg" alt="图片"></p><ol start="3"><li>仓库名称填写 github用户名.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a>，如图所示，这里演示的用户名是robotdigital，所以填<a href="https://link.zhihu.com/?target=http://robotdigital.github.io">http://robotdigital.github.io</a>，勾选“带README的仓库”，最后点击“Creat repository”</li></ol><p>  <img src="https://pic4.zhimg.com/v2-84b436c2285c66c452877fa80a2b54bb_r.jpg" alt="图片2"></p><ol start="4"><li>则成功创建了一个名为<a href="https://link.zhihu.com/?target=http://robotdigital.github.io">http://robotdigital.github.io</a>的repository（仓库）</li></ol><p><img src="https://pic3.zhimg.com/v2-b8dafc2093fcf7d48e9af14a667cbfba_r.jpg" alt="图片3"></p><h2 id="博客部署-1"><a href="#博客部署-1" class="headerlink" title="博客部署"></a>博客部署</h2><ol><li>打开hexo博客所在的blog文件夹中的_config.yml，在Deployment模块配置如图所示的信息（注意repository要换成自己GitHub仓库中的哦）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:peter-ggb/peter-ggb.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>repository内容如图所示：</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220303135640419.png" alt="图片"></p><p>注意：编辑config.yml 文件时 有严格的语法要求，包括空格，不能随意更改</p><ol start="2"><li>在blog文件下打开git Bash输入以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这行命令的含义是将本地文件部署到你的GitHub库中，与下面的命令作用是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>结果发现如图所示的报错，Permission denied(publickey)，拒绝访问（公共密钥）</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220303141817461.png" alt="image-20220303141817461"></p><h2 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h2><p>因为没有将本机加入到GitHub的信任名单中，所以将博客发布到GitHub服务器这样的远程操作被拒绝。 接下来我们需要创建SSH key（简单说，SSH是一种网络协议，用于计算机之间的加密登录） 。</p><ol><li><p>首先进入gitHub，点击右上角的头像，选择settings，在左边选择SSH and GPG keys ，点击New SSH key，然后会让你选择时间以及其他选项（在这里我做的选择是90天，然后下面的全部勾选，根据自己的需求做合理的调整）</p></li><li><p>然后这里需要我们输入密钥，标题随意命名，这里我们先等下再填</p></li><li><p>然后进入blog文件下打开git bash，输入如下命令,邮箱名就是你注册GitHub上所用的邮箱名</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱名&quot;</span><br></pre></td></tr></table></figure><p>回车执行命令，然后就是这样</p><p><img src="https://pic4.zhimg.com/v2-aae30fb6e47e7eb0074522f9ed6b4e33_r.jpg" alt="图片5"></p><p>现在是要求我们输入密码，这个密码会在我们提交项目时使用，如果为空的话提交项目时则不用输入。防止别人往你的项目里提交内容，这里我选择输入了自己的密码，密码就是你注册GitHub上的密码，这样就成功生成了密钥，并且密钥信息存储在<strong>C:\Users\CNBOXIA1.ssh\id_rsa.pub</strong> 中。</p><p><img src="https://pic3.zhimg.com/v2-3b42b3fad78ee146cdd1111171af18d2_r.jpg" alt="图片6"> </p><p>用记事本打开id_rsa.pub文件，将里面的内容复制到Key输入框中，最后点击“Add SSH key”。</p><p><img src="https://pic2.zhimg.com/v2-66ae7414d4e1f5f196ced32080378621_r.jpg" alt="图片4"></p><p>这样密钥就添加成功了</p><p>注意：这里一定要将密钥保存下来，比如存在你的记事本里，手机拍照等等，因为等你添加密钥之后他就会隐藏不再显示，再想获取这个密钥就不太可能了，千万要保存！千万要保存！千万要保存！</p><p>当然如果没保存也有解决办法，就是再创建一个密钥，这两个密钥对下面的操作影响是一样的，也可以同时存在，只是要再花时间去创建而已（我就是重新创建了一个)</p><h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>在blog文件夹下执行以下命令,hexo clean代表清理缓存,hexo g代表部署之前预先生成静态文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220303143829094.png" alt="image-20220303143829094"></p><p>无报错，表示部署成功。</p><p>过一小会，在浏览器中输入<a href="https://link.zhihu.com/?target=http://robotdigital.github.io">http://robotdigital.github.io</a>（robotdigital替换成自己创建的github用户名），则成功看到了博客页面，表明我们成功将个人博客发布到了GitHub上。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220303143955230.png" alt="image-20220303143955230"></p><p>快去看看吧</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第一章</title>
      <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第一章"><a href="#数据结构第一章" class="headerlink" title="数据结构第一章"></a>数据结构第一章</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h3><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</p><h3 id="数据结构的组成"><a href="#数据结构的组成" class="headerlink" title="数据结构的组成"></a>数据结构的组成</h3><p>包括逻辑结构和存储结构两个层次</p><p>逻辑结构：</p><p>先说逻辑结构，逻辑结构是从逻辑关系上描述数据</p><p>逻辑结构有两个要素：数据元素和关系，通常有四类基本特征，复杂程度依次递进<br>如下图所示：<br><img src="D:\blog\source\img/tu1.png" alt="图1"></p><ul><li>集合结构：除了属于同一集合的关系外，没有别的关系</li><li>线性结构：数据元素存在一对一的关系</li><li>树结构：数据元素之间存在一对多的关系</li><li>图结构或网状结构：数据元素之间存在多对多的关系</li></ul><p>还可以从线性和非线性的角度给逻辑结构分类<br>如下图所示：<br><img src="D:\blog\source\img/tu2.png" alt="图2"></p><p>存储结构：</p><p>数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构</p><p>数据的存储结构会影响</p><ul><li>1.存储空间分配的方便程度</li><li>2.对数据运算的速度</li></ul><p>数据元素在计算机中有四种存储结构，分别是：</p><ul><li>顺序存储  顺序存储 借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系</li><li>链式存储  非顺序存储 无需占用一整块存储空间，也就是说不要求物理上相邻</li><li>索引存储  非顺序存储 建立附加的索引表，索引表中每项是索引项</li><li>散列存储  非顺序存储 （还需补充）</li></ul><h3 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h3><p>数据的运算包括：检索，排序，修改，插入，删除等</p><h3 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h3><p>数据类型：</p><ul><li>原子类型：不可再分的类型（如int）</li><li>结构类型：可再分的类型（如struct）</li></ul><p>抽象数据类型：<br>一般是指由用户定义的，表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：</p><ul><li>数据对象</li><li>数据对象上关系的集合</li><li>对数据对象的基本操作的集合、</li></ul><p>抽象数据定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">    数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">    数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">    基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><p>数据对象和数据关系的定义采用数学符号和自然语言描述，基本格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本操作名（参数表）</span><br><span class="line">     基本条件：&lt;初始条件描述&gt;</span><br><span class="line">     操作结果：&lt;操作结果描述&gt;</span><br></pre></td></tr></table></figure><h3 id="算法定义及特征"><a href="#算法定义及特征" class="headerlink" title="算法定义及特征"></a>算法定义及特征</h3><p>一个算法必须满足以下五个重要特性</p><ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ul><h3 id="评价算法优劣的基本准则"><a href="#评价算法优劣的基本准则" class="headerlink" title="评价算法优劣的基本准则"></a>评价算法优劣的基本准则</h3><ul><li>正确性</li><li>可行性</li><li>健壮性</li><li>高效性</li></ul><h3 id="算法的时间复杂度计算"><a href="#算法的时间复杂度计算" class="headerlink" title="算法的时间复杂度计算"></a>算法的时间复杂度计算</h3><p>加法规则：多项相加，只保留最高阶的项且系数为1<br>乘法规则：多项相乘，都保留</p><p>算法的时间复杂度O(1)&lt;O($$log_2n $$)&lt;O(n)&lt;O($$nlog_2 n$$)&lt;O($$ n^2$$)&lt;O($$ n^3$$)&lt;O($$ 2^n$$)&lt;O(n!)&lt;O($$n^n$$);</p><p>复杂度口诀：常对幂指阶（常数&lt;对数&lt;幂&lt;指数&lt;阶数）</p><p>最好、最坏和平均时间复杂度（有待更新）</p><p>注意：</p><ul><li>顺序执行的代码只会影响常数项，可以忽略</li><li>只需挑循环中一个基本操作分析它的执行次数与n的关系即可</li><li>如果有多层嵌套循环只需关注，最深层循环了几次</li></ul><h3 id="算法的空间复杂度计算"><a href="#算法的空间复杂度计算" class="headerlink" title="算法的空间复杂度计算"></a>算法的空间复杂度计算</h3><p>复杂度口诀：常对幂指阶（常数&lt;对数&lt;幂&lt;指数&lt;阶数）</p><p>空间复杂度&#x3D;递归调用的深度<br>（有待继续总结）</p><p>注意</p><ul><li>算法原地工作&#x3D;算法所需的内存空间为常量</li></ul><p>最后总结：<br><img src="D:\blog\source\img/tu3.png" alt="图3"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第二章</title>
      <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第二章"><a href="#数据结构第二章" class="headerlink" title="数据结构第二章"></a>数据结构第二章</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>特点：同一线性表中的元素必定具有相同的特性，即同属于同一数据对象，相邻数据元素之间存在着序偶关系。</p><p>定义：由n（n&gt;&#x3D;0）个数据特性相同的元素对象组成的有限序列，称为线性表，n为线性表的长度，n&#x3D;0时为空表</p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h2><p>基本操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">InitList(&amp;L) <span class="comment">//建立一个空的线性表</span></span><br><span class="line"></span><br><span class="line">DestroyList(&amp;L) <span class="comment">//删除一个线性表</span></span><br><span class="line"></span><br><span class="line">ClearList(&amp;L) <span class="comment">//将L置为空表</span></span><br><span class="line"></span><br><span class="line">ListEmpty(L) <span class="comment">//线性表判空，空则返回true 不空false</span></span><br><span class="line"></span><br><span class="line">ListLength(L) <span class="comment">//返回线性表元素个数</span></span><br><span class="line"></span><br><span class="line">GetElem(L,i,&amp;e) <span class="comment">//用e返回第i个元素的值</span></span><br><span class="line"></span><br><span class="line">LocateElem(L,e) <span class="comment">//返回线性表L中第一个元素值与e相同元素的位置</span></span><br><span class="line"> </span><br><span class="line">ListInsert(&amp;L,i,e) <span class="comment">//在线性表L的第i个位置前插入元素e，L长度加一</span></span><br><span class="line"></span><br><span class="line">ListDelete(&amp;L,i) <span class="comment">//在线性表L删除第i位置的元素，L长度减一</span></span><br><span class="line"></span><br><span class="line">TraverseList(L) <span class="comment">//在线性表L中进行遍历，在遍历过程中对L的每个节点访问一次</span></span><br></pre></td></tr></table></figure><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><p>顺序表是用一组连续的地址单元空间存储线性表的数据元素</p><p>线性表的存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType elem <span class="comment">//元素基地址</span></span><br><span class="line"><span class="type">int</span> len <span class="comment">//当前长度</span></span><br><span class="line">&#125;Sqlist <span class="comment">//线性表类型</span></span><br></pre></td></tr></table></figure><h2 id="顺序表的基本操作实现"><a href="#顺序表的基本操作实现" class="headerlink" title="顺序表的基本操作实现"></a>顺序表的基本操作实现</h2><h3 id="顺序表建立"><a href="#顺序表建立" class="headerlink" title="顺序表建立"></a>顺序表建立</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">InitList</span><span class="params">(&amp;L)</span>&#123;</span><br><span class="line">L.elem=new ElemType(MAXSIZE);</span><br><span class="line"><span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">L.len=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取顺序表值"><a href="#取顺序表值" class="headerlink" title="取顺序表值"></a>取顺序表值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">GetElem</span><span class="params">(L,i,&amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||L.len&lt;i) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判断i是否合法</span></span><br><span class="line">e=L.elem[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表查找元素"><a href="#顺序表查找元素" class="headerlink" title="顺序表查找元素"></a>顺序表查找元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">LocateElem</span><span class="params">(L,e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e==L.elem[i]) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">retrun <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">ListInsert</span><span class="params">(&amp;L,i,e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L.len) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(L.len==MAXSIZE) reutrn ERROR;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L.len<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">&#125;</span><br><span class="line">L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">++L.len;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br></pre></td></tr></table></figure><p>顺序表的插入的时间复杂度为o(n)</p><h3 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">ListDelete</span><span class="params">(&amp;L,i)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;L.len||i&lt;<span class="number">0</span>) retrun ERROR;</span><br><span class="line"><span class="keyword">if</span>(L.len==<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.len;j++)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[i<span class="number">-1</span>]=L.elem[i];</span><br><span class="line">&#125;</span><br><span class="line">--L.len;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序表的删除时间复杂度为o(n)</p><h3 id="顺序表的遍历"><a href="#顺序表的遍历" class="headerlink" title="顺序表的遍历"></a>顺序表的遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">status <span class="title function_">TraverseList</span><span class="params">(L)</span>&#123;</span><br><span class="line"><span class="type">int</span> e=get; <span class="comment">//遍历标志</span></span><br><span class="line"><span class="keyword">if</span>(L.len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.len;i++)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[i]=e; <span class="comment">//遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK; <span class="comment">//遍历成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表的存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElemType data; <span class="comment">//节点数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>； //节点的指针域</span></span><br><span class="line"><span class="class">&#125;<span class="title">LNode</span>,*<span class="title">LinkList</span>;</span> <span class="comment">//LinkList为指向结构体LNode的指针类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h3><p>单链表初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L=new LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    LNode p=new LNode;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;i||p)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;i||!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表按值查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status *<span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode p=new LNode;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表的插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status *<span class="title function_">insertElem</span><span class="params">(LinkList &amp;L,ElemType e,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    LNode p=new LNode;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LNode s=new LNode;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表的删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Status *<span class="title function_">deleteElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    LNode p=new LNode;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-2</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-2</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LNode s=new LNode;</span><br><span class="line">    s=p-&gt;next;</span><br><span class="line">    p-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建单链表</p><ol><li><p>前插法创建单链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status *<span class="title">createElemqian</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    LNode L=<span class="keyword">new</span> Node;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        LNode p=<span class="keyword">new</span> LNode;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后插法创建单链表</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status *<span class="title">createElemhou</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    LNode L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    LNode p=L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        LNode s=<span class="keyword">new</span> LNode;</span><br><span class="line">        cin&gt;&gt;s-&gt;data;</span><br><span class="line">        s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=s;</span><br><span class="line">        p=s; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是另一种形式的链式存储结构，其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。</p><p>将两个循环链表合成一个表</p><p>![img](file:&#x2F;&#x2F;&#x2F;C:\Users\lenovo\Documents\Tencent Files\523785331\Image\C2C\EFDEB4602FE683000E52CED5A8A46312.jpg)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LNode p=<span class="keyword">new</span> LNode;</span><br><span class="line">p=B-&gt;next-&gt;next;</span><br><span class="line">B-&gt;next=A-&gt;next;</span><br><span class="line">A-&gt;next=p;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表节点存在两个指针域，分别为前驱和后继，可描述如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DuLNode</span>&#123;</span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> *prior; <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> *next; <span class="comment">//后继指针</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure><h3 id="双向链表的基本操作的实现"><a href="#双向链表的基本操作的实现" class="headerlink" title="双向链表的基本操作的实现"></a>双向链表的基本操作的实现</h3><p>双向链表的插入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    DuLNode p=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    p=<span class="built_in">GetElem_Dul</span>(L,i);<span class="comment">//将p指向节点i</span></span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    DuLNode s=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;perior=s;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    s-&gt;perior=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向链表的删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_Dul</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    DuLNode p=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    p=<span class="built_in">GetElem_Dul</span>(L,i);<span class="comment">//将p指向节点i</span></span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;perior-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;perior=p-&gt;perior;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;perior=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F765%2Fa1f8aa464410a9978ce80c6205a037f5.png&refer=http%3A%2F%2Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648902451&t=f73a2c810b9407faf0f5cfc788683e5d" alt="图"></p><p>存储密度&#x3D;数据元素本身占用的存储量&#x2F;结点结构占用的存储量</p><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="线性表的合并"><a href="#线性表的合并" class="headerlink" title="线性表的合并"></a>线性表的合并</h3><p>已知存在A,B两个表，要将这两个表合成一个表（不能创造新的表）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(List &amp;LA,List LB)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m=<span class="built_in">ListLength</span>(LA);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">ListLength</span>(LB);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">GetELem</span>(LB,i,e);<span class="comment">//将LB第i个元素的值赋值给e</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(LA,e)) <span class="built_in">InsertElem</span>(LA,++m,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序有序表的合并"><a href="#顺序有序表的合并" class="headerlink" title="顺序有序表的合并"></a>顺序有序表的合并</h3><p>已知存在A,B两个顺序有序表，要将A,B两个表合成为C表，c表也是顺序有序表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_youxu</span><span class="params">(List LA,List LB)</span></span>&#123;</span><br><span class="line">    NodeList LC=<span class="keyword">new</span> NodeList;</span><br><span class="line">    <span class="built_in">initList</span>(LC);</span><br><span class="line">    x=<span class="built_in">ListLength</span>(LC);</span><br><span class="line">    n=<span class="built_in">ListLength</span>(LA);</span><br><span class="line">    m=<span class="built_in">ListLength</span>(LB);</span><br><span class="line">    *p=LA;</span><br><span class="line">    *s=LB;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.elem[i]&lt;s.elem[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">InsertElem</span>(LC,++x,p.elem[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">InsertElem</span>(LC,++x,s.elem[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) </span><br><span class="line">        <span class="keyword">while</span>(s)&#123;</span><br><span class="line">            <span class="built_in">InsertElem</span>(LC,++x,s.elem[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="built_in">InsertElem</span>(LC,++x,p.elem[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式有序表的合并"><a href="#链式有序表的合并" class="headerlink" title="链式有序表的合并"></a>链式有序表的合并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_L</span><span class="params">(LNodeList LA,LNodeList LB)</span></span>&#123;</span><br><span class="line">    pa=LA-&gt;next;</span><br><span class="line">    pb=LB-&gt;next;</span><br><span class="line">    LC=LA;</span><br><span class="line">    pc=LC;</span><br><span class="line">    <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pa;</span><br><span class="line">            pc=pa;</span><br><span class="line">            pa=pa-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pb;</span><br><span class="line">            pc=pb;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next=pa?pa:pb;</span><br><span class="line">    <span class="keyword">delete</span> LB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单项表，循环链表，双向表的比较"><a href="#单项表，循环链表，双向表的比较" class="headerlink" title="单项表，循环链表，双向表的比较"></a>单项表，循环链表，双向表的比较</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20190922215812533.jpg%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dLWF81%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648905961&t=b795507138931ce5cc9628418bf4f8a6" alt="图片"></p><p>第二章搞完</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第三章</title>
      <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构第三章"><a href="#数据结构第三章" class="headerlink" title="数据结构第三章"></a>数据结构第三章</h1><h2 id="栈的定义和特点"><a href="#栈的定义和特点" class="headerlink" title="栈的定义和特点"></a>栈的定义和特点</h2><p>栈是限定仅在表尾进行插入或删除操作的线性表，表尾端有特殊含义，称为栈顶，表头段称为栈底，不含元素的空表称为空栈，又称为后进后出的线性表</p><p>逻辑结构：与普通列表相同</p><h2 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a>队列的定义和特点</h2><p>队列与栈相反，是先进先出的线性表，只允许在表的一端进行插入，另一端允许删除，允许插入的一端称为队尾，允许删除的一端称为队头</p><h2 id="栈的表示和实现"><a href="#栈的表示和实现" class="headerlink" title="栈的表示和实现"></a>栈的表示和实现</h2><h3 id="栈类型的定义"><a href="#栈类型的定义" class="headerlink" title="栈类型的定义"></a>栈类型的定义</h3><p>基本操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">InitStack</span>(&amp;S) <span class="comment">//构造一个空栈</span></span><br><span class="line"><span class="built_in">DestroyStack</span>(&amp;S) <span class="comment">//销毁栈S</span></span><br><span class="line"><span class="built_in">ClearStack</span>(&amp;S) <span class="comment">//将S清为空栈</span></span><br><span class="line"><span class="built_in">StackEmpty</span>(S) <span class="comment">//若栈为空栈，返回true，若非空则返回False</span></span><br><span class="line"><span class="built_in">StackLength</span>(S) <span class="comment">//返回S的元素个数</span></span><br><span class="line"><span class="built_in">GetTop</span>(S) <span class="comment">//返回栈顶指针元素，不修改栈顶指针</span></span><br><span class="line"><span class="built_in">Push</span>(&amp;S,e) <span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line"><span class="built_in">Pop</span>(&amp;S,e) <span class="comment">//删除S的栈的元素</span></span><br><span class="line"><span class="built_in">StackTraverse</span>(S) <span class="comment">//从栈底到栈顶依次对S的每个数据元素进行访问</span></span><br></pre></td></tr></table></figure><h3 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h3><p>顺序栈存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemTyoe *base;<span class="comment">//栈底指针</span></span><br><span class="line">    SElemType *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="type">int</span> stacksize；<span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>顺序栈的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序栈的入栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base==MAXSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line">    *S.top++=e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序栈的出栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=*--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取栈顶元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> *(S.top<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h3><p>链栈的存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StackNode</span> *next;</span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure><p>链栈的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的入栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    StackNode p=<span class="keyword">new</span> StackNode;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S;</span><br><span class="line">    S=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的出栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=S-&gt;data;</span><br><span class="line">    p=S;</span><br><span class="line">    S=S-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取链栈元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><p>遍历输出链表中各个结点的递归算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseList</span><span class="params">(LinkList p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p=<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;p&lt;&lt;p-&gt;data;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="built_in">TraverseList</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hanoi塔问题的递归问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> A,<span class="type">char</span> B,<span class="type">char</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="built_in">move</span>(A,<span class="number">1</span>,C);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">Hanoi</span>(n<span class="number">-1</span>,A,C,B);</span><br><span class="line">        <span class="built_in">move</span>(A,n,C);</span><br><span class="line">        <span class="built_in">Hanoi</span>(n<span class="number">-1</span>,B,A,C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据最终结果计算，递归算法计算Fibonacci和Hanoi问题算法时间复杂度都是o($$2^n $$)</p><h2 id="队列的表示和实现"><a href="#队列的表示和实现" class="headerlink" title="队列的表示和实现"></a>队列的表示和实现</h2><h3 id="队列的类型定义"><a href="#队列的类型定义" class="headerlink" title="队列的类型定义"></a>队列的类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ADT Quene&#123;</span><br><span class="line">     <span class="built_in">InitQuene</span>(&amp;Q) <span class="comment">//构造一个空队列</span></span><br><span class="line">     <span class="built_in">DestroyQuene</span>(&amp;Q) <span class="comment">//x销毁队列Q</span></span><br><span class="line">     <span class="built_in">ClearQuene</span>(&amp;Q) <span class="comment">//将Q置为空队列</span></span><br><span class="line">     <span class="built_in">QueneEmpty</span>(Q) <span class="comment">//若Q为空返回true，反之则为false</span></span><br><span class="line">     <span class="built_in">QueneLength</span>(Q) <span class="comment">//返回Q的元素个数即队列长度    </span></span><br><span class="line">     <span class="built_in">GetHead</span>(Q) <span class="comment">//返回Q的队头元素  </span></span><br><span class="line">     <span class="built_in">EnQuene</span>(&amp;Q,e) <span class="comment">//插入元素e为队尾元素</span></span><br><span class="line">     <span class="built_in">DeQuene</span>(&amp;Q,&amp;e) <span class="comment">//删除Q的队头元素，并用e返回其值</span></span><br><span class="line">     <span class="built_in">QueneTraverse</span>(Q) <span class="comment">//从队头到队尾依次对每个数据元素进行访问    </span></span><br><span class="line">&#125;ADT Quene</span><br></pre></td></tr></table></figure><h3 id="循环队列的顺序表示和实现"><a href="#循环队列的顺序表示和实现" class="headerlink" title="循环队列的顺序表示和实现"></a>循环队列的顺序表示和实现</h3><p>循环队列的顺序存储形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QElemType *base;<span class="comment">//存储空间的基地址</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">//头指针</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQuene;</span><br></pre></td></tr></table></figure><p>循环队列的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQuene</span><span class="params">(SqQuene &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.base=<span class="keyword">new</span> QElemTyoe[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!Q) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求循环队列的长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueneLength</span><span class="params">(SqQuene Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQuene</span><span class="params">(SqQuene &amp;Q,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXSIZE==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.<span class="built_in">base</span>(Q.rear)=e;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列出队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQuene</span><span class="params">(SqQuene &amp;Q,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=Q.<span class="built_in">base</span>(Q.front);</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取循环队列的对头元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QElemType <span class="title">GetTop</span><span class="params">(SqQuene Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> Q.<span class="built_in">base</span>(Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式表示和实现"><a href="#队列的链式表示和实现" class="headerlink" title="队列的链式表示和实现"></a>队列的链式表示和实现</h3><p>队列的链式存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span>  <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QuenePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QuenePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QuenePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQuene;</span><br></pre></td></tr></table></figure><p>链队列的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQuene</span><span class="params">(LinkQuene &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=<span class="keyword">new</span> QNode;</span><br><span class="line">    Q.front=Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链队列的入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQuene</span><span class="params">(LinkQuene &amp;Q,QElemType e)</span></span>&#123;</span><br><span class="line">    QNode p=<span class="keyword">new</span> Node;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链队列的出队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQuene</span><span class="params">(LinkQuene &amp;Q,QElemtype e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p) Q,rear=Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取链队列的队头元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetHead</span><span class="params">(LinkQuene Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front!=Q.rear)</span><br><span class="line">        <span class="keyword">return</span> Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p>数制的转换</p><p>将一个十进制整数N转换为八进制数时，在计算过程中，把N与8求余得到的八进制数依次出栈输出，输出结果就是带求得得八进制数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(N/<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="type">int</span> e=N%<span class="number">8</span>;</span><br><span class="line">        <span class="built_in">Push</span>(&amp;S,e);</span><br><span class="line">        N/=<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(&amp;S,e);</span><br><span class="line">        cout&lt;&lt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>括号匹配的检验</p><p>检验算法借助一个栈，每当读入一个左括号，则直接入栈，等待相匹配的同类右括号，当读入一个右括号，若与当前栈顶的左括号类型相同则二者匹配，即将栈顶的左括号出栈，直接表达式扫描完毕。</p><p>在扫描过程中，还要考虑符号不匹配出错的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Matching</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;#&#x27;</span>&amp;&amp;flag)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                <span class="built_in">Push</span>(&amp;S,e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(!StackEmpty&amp;&amp;GetTop==<span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                    <span class="built_in">Pop</span>(&amp;S,e);</span><br><span class="line">                <span class="keyword">else</span> flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(!StackEmpty&amp;&amp;GetTop==<span class="string">&#x27;[&#x27;</span>) </span><br><span class="line">                    <span class="built_in">Pop</span>(&amp;S,e);</span><br><span class="line">                <span class="keyword">else</span> flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty&amp;&amp;flag!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式求值</p><p>遵循三条规则</p><ol><li>先乘除，后加减</li><li>从左算到右</li><li>先括号内，后括号外</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">EvaluateExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPND);</span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR);</span><br><span class="line">    <span class="built_in">push</span>(&amp;OPTR,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;#&#x27;</span>||<span class="built_in">GetTop</span>(OPTR)!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                <span class="built_in">push</span>(OPND,ch);</span><br><span class="line">                cin&gt;&gt;ch;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                <span class="built_in">Pop</span>(OPTR,fuhao);</span><br><span class="line">                <span class="built_in">Pop</span>(OPND,e1);</span><br><span class="line">                <span class="built_in">Pop</span>(OPND,e2);</span><br><span class="line">                <span class="built_in">Push</span>(OPND,<span class="built_in">Operate</span>(e1,fuhao,e2));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                <span class="built_in">Pop</span>(OPTR,e3);</span><br><span class="line">                cin&gt;&gt;ch;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetTop</span>(OPND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>舞伴问题</p><p>会场中有若干男舞者和若干女舞者，需要将他们一 一配对</p><p>解决这个问题我们首先要写出舞者的数据结构</p><p>这里我们用链队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    String name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;Person;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    Person *base; <span class="comment">//指向peron的指针</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;SQuene;</span><br><span class="line">SQuene manQuene,womanQuene;<span class="comment">//分别存放男舞者队列与女舞者队列</span></span><br></pre></td></tr></table></figure><p>之后来解决问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DanceProblem</span><span class="params">(Person Dancer[],<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitQuene</span>(manQuene);</span><br><span class="line">    <span class="built_in">InitQuene</span>(womanQuene);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dancer[i].sex==<span class="string">&#x27;m&#x27;</span>) <span class="built_in">EnQuene</span>(manQuene,Dancer[i]);</span><br><span class="line">        <span class="keyword">if</span>(Dancer[i].sex==<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">EnQuene</span>(womanQuene,Dancer[i]);       </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">QueneEmpty</span>(manQuene)&amp;&amp;!<span class="built_in">QueneEmpty</span>(womanQuene))&#123;</span><br><span class="line">        <span class="built_in">DeQuene</span>(manQuene,p);</span><br><span class="line">        cout&lt;&lt;p.name&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">DeQuene</span>(womanQuene,w);</span><br><span class="line">        cout&lt;&lt;w.name&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">QueneEmpty</span>(manQuene))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;现在等待舞伴的第一个男舞者：&quot;</span>&lt;&lt;p.name&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">QueneEmpty</span>(womanQuene))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;现在等待舞伴的第一个女舞者：&quot;</span>&lt;&lt;w.name&lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220308155251329.png" alt="图片"></p><p>第三章完结</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客排坑之路</title>
      <link href="/2022/02/28/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%8E%92%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/02/28/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%8E%92%E5%9D%91%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="问题-在给博客配音乐的时候出现问题"><a href="#问题-在给博客配音乐的时候出现问题" class="headerlink" title="问题 在给博客配音乐的时候出现问题"></a>问题 在给博客配音乐的时候出现问题</h1><h2 id="问题原因和解决办法"><a href="#问题原因和解决办法" class="headerlink" title="问题原因和解决办法"></a>问题原因和解决办法</h2><p>我先摆出问题</p><p><img src="/../img/wenti1.png" alt="问题一"></p><p><img src="/./img/wenti2.png" alt="问题二"></p><p>这可能是我最无可奈何的时候，因为看不懂问题所处在哪里，事先也没有备份文件，导致我重新配了一遍主题，通过排错知道了问题在——主题配置文件中</p><p>原因就出在我在配置主题文件中误改了搜索系统</p><p>原本butterfly主题中可以选择本地搜索或者algolia，butterfly文档中也有详细的介绍：<a href="https://butterfly.js.org/posts/ceeb73f/">butterfly主题文档</a></p><p>言归正传，我选择的是本地搜索系统，但是我改的是algolia，错误的将false改成了true，具体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Algolia search</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: false     &lt;- 这里（我错误的将false改为了true，而我应用的是本地搜索，所以报错了5555,查了好久/(ㄒoㄒ)/~~）</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 6</span><br></pre></td></tr></table></figure><p>把它改回来就解决了</p><p>然后在安装音乐过程中，由于我当时安装butterfly是用的npm方式，所以我要找的layout文件没有在theme目录下</p><p>该文件是在node_modules&#x2F;hexo-theme-butterfly文件下（找了好久555ㄒoㄒ）</p><p>然后我跟着csdn上的教程一步一步做，发现根本不用改layout.pug和aplayer.pug文件</p><p>但是之前安装命令还是必要的</p><h2 id="实现音乐功能"><a href="#实现音乐功能" class="headerlink" title="实现音乐功能"></a>实现音乐功能</h2><p>实现音乐功能如下：</p><p>先定位到blog文件下，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new page music</span><br><span class="line"></span><br><span class="line">npm install aplayer</span><br><span class="line"></span><br><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>之后打开你博客根目录下的_config.yml，在最后添加以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#aplayer</span><br><span class="line">aplayer: </span><br><span class="line">  script_dir: js                      # Public 目录下脚本目录路径，默认: &#x27;assets/js&#x27;</span><br><span class="line">  style_dir: css                         # Public 目录下样式目录路径，默认: &#x27;assets/css&#x27;</span><br><span class="line">  #cdn: http://xxx/aplayer.min.js                # 引用 APlayer.js 外部 CDN 地址 (默认不开启)</span><br><span class="line">  #style_cdn: http://xxx/aplayer.min.css         # 引用 APlayer.css 外部 CDN 地址 (默认不开启)</span><br><span class="line">  meting: true                                  # MetingJS 支持</span><br><span class="line">  #meting_api: http://xxx/api.php                # 自定义 Meting API 地址</span><br><span class="line">  #meting_cdn: http://xxx/Meing.min.js           # 引用 Meting.js 外部 CDN 地址 (默认不开启)</span><br><span class="line">  asset_inject: true                            # 自动插入 Aplayer.js 与 Meting.js 资源脚本, 默认开启</span><br><span class="line">  #externalLink: http://xxx/aplayer.min.js       # 老版本参数，功能与参数 cdn 相同meting: true</span><br></pre></td></tr></table></figure><p>并在_config.yml调整post_asset_folder如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>最后一步在博客根目录\source\music\index.md使用以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的歌单</span><br><span class="line">date: 2019-05-17 16:14:00</span><br><span class="line">cover: https://cdn.jsdelivr.net/gh/radium-bit/res@latest/Music.jpg</span><br><span class="line">type: &quot;music&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;font color=#0c74d6 size=3 face=&quot;黑体&quot;&gt;**这是歌单介绍，如果不需要刻意留空**&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&#123;% meting &quot;697054881&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;   // 这一行请查看文档自行修改</span><br></pre></td></tr></table></figure><p>那一串数字是歌单ID，“netease”为网易云音乐。详细参数用法请参考<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">官方文档</a><br>歌单ID提取方法是以链接分享某个歌单<br>例如<br><a href="https://music.163.com/playlist?id=313418853&amp;userid=1362990007">https://music.163.com/playlist?id=313418853&amp;userid=1362990007</a></p><p>313418853就是歌单ID了</p><p>写入完毕后，在博客根目录下输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成完毕！最后差不多是这样：<br><img src="/./img/jieguo1.png" alt="问题一"></p><p>我真的搞了好久，这种问题真的是太致命了，长个记性，下次改文件之前需要先备份一份</p><p>得去回回血了枯😭</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客排坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/28/hello-world/"/>
      <url>/2022/02/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客心得</title>
      <link href="/2022/02/23/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"/>
      <url>/2022/02/23/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="搭建前提"><a href="#搭建前提" class="headerlink" title="搭建前提"></a>搭建前提</h2><ul><li>需要安装git</li><li>需要安装Node.js</li><li>需要安装Hexo</li></ul><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。<a href="https://www.liaoxuefeng.com/wiki/896043488029600">git教程</a></p><p>windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。<br>git官网链接：<a href="https://git-scm.com/">https://git-scm.com</a></p><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h2><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：nodejs选择LTS版本就行了。<br>官网地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>linux：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装完后，打开git bash命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h2><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>利用’hexo -v’查看一下版本</p><p>安装就此完成</p><h2 id="4-查看成果"><a href="#4-查看成果" class="headerlink" title="4.查看成果"></a>4.查看成果</h2><p>首先初始化一下hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><p>这个myblog可以自己取什么名字都行，然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p>在git bash中输入以下命令打开你自己生成的博客了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>大概长这个样子<br><img src="https://monster-zero.github.io/newlife.github.io/person/23.png"></p><p>至此博客就在本地搭建完成啦！</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
